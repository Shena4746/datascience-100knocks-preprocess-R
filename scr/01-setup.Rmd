# 準備と予備知識 {#setup}

Postgres DB がどこかに立ててあると想定して, R から DB へ接続する. その後, DB 上のデータを dbplyr で扱うための最低限の知識をレビューする.

チュートリアルとしては, 以下も参考になる. 必要に応じて参照されたい.

- [Introduction to dbplyr](https://dbplyr.tidyverse.org/articles/dbplyr.html)
- [巨大なデータがSQLサーバーにあるときに、Rでどう立ち向かうかマニュアル：dbplyrパッケージを中心として](https://yutatoyama.github.io/note/intro_R_for_SQL.html)

## R から DB への接続

[Introduction to dbplyr](https://dbplyr.tidyverse.org/articles/dbplyr.html) 記載の方法に従う.

必須パッケージ達.
最初の2つは DB への接続用.

```{r libraries, include=FALSE}
library("DBI")
library("RPostgres")
library("dbplyr")
library("dplyr")
```

```{r versions-of-libraries, collapse=TRUE}
R.version.string # R version
packageVersion("RPostgres")
packageVersion("DBI")
packageVersion("dbplyr")
packageVersion("dplyr")
```

まだしてなければ, bash を叩いて Postgres を起動.
```{bash, eval=FALSE}
sudo service postgresql start
```

[Introduction to dbplyr](https://dbplyr.tidyverse.org/articles/dbplyr.html) は, DB 接続のためのコードとして以下の例と注意を述べている:
(この例では `RPostgreSQL::PostgreSQL()` とされていることに注意.)

```{r example1-connect-to-DB, eval=FALSE}
con <- DBI::dbConnect(
    drv = RPostgreSQL::PostgreSQL(),
    host = "database.rstudio.com",
    user = "your-name",
    password = rstudioapi::askForPassword("Database password")
)
```

>If you’re not using RStudio, you’ll need some other way to securely retrieve your password. You should never record it in your analysis scripts or type it into the console. [Securing Credentials](https://db.rstudio.com/best-practices/managing-credentials) provides some best practices.

これを踏まえると, 以下の接続方法は大変行儀が悪いが, 今回はどうせ localhost にこのノック限定で立てている DB だろうから, ここでは咎めないことにする. 

```{r example2-connect-to-DB, eval=FALSE}
con <- DBI::dbConnect(
    drv = RPostgres::Postgres(),
    host = "localhost",
    port = 5432,
    dbname = "your-database-name",
    user = "your-user",
    password = "your-password"
)
```

```{r connect-to-DB, eval = TRUE, include=FALSE}
dw <- config::get("datascience-100knocks-preprocess")
con <- DBI::dbConnect(
    drv = RPostgres::Postgres(),
    host = dw$host,
    port = dw$port,
    dbname = dw$dbname,
    user = dw$user,
    password = dw$password
)
```

接続できたか確認.

```{r show-databases, message=TRUE}
DBI::dbListTables(con)
```

## dbplyr ミニハンズオン

\@ref(about-dbplyr) で述べた作業フローに挙げた項目を, サンプルコードを示す. 
知識習得の目的をノックを倒すことの限定すれば, テーブルの参照の取得方法と `collect()` の使い方が分かれば問題ない. より詳細を知るには, \@ref(references) References に挙げた文献が有用.

まずは, DB 上のテーブルへの参照を取得しよう. 

### テーブルへの参照

```{r name-variables, eval=TRUE}
customer_tbl <- dplyr::tbl(con, "customer")
category_tbl <- dplyr::tbl(con, "category")
product_tbl <- dplyr::tbl(con, "product")
receipt_tbl <- dplyr::tbl(con, "receipt")
store_tbl <- dplyr::tbl(con, "store")
customer_tbl %>% class()
```

なお, この参照は `DBI::dbDisconnect()` によって失われる. 次に, この参照を使ってクエリが飛ばせるかテスト. 

```{r query-test}
receipt_tbl %>%
    filter(amount >= 1000) %>%
    head()
```

このとき返されるのは実データとしての `tibble` ではなく, 入力元のリモートテーブルと同じ `tbl_dbi` オブジェクトである. dbplyr の文脈では `tbl_lazy` と呼ばれることも多いようだ.

```{r tbl_dbi_class}
receipt_tbl %>%
    filter(amount >= 1000) %>%
    head() %>%
    class()
```

### 利用できない R 関数例
 
実データではないので, `tbl_dbi %>% nrow()` は常に `NA` になる.

```{r nrow-does-not-works}
receipt_tbl %>% nrow()
```

代替手段としては, `summarise` で数えてもらえばよい. 

```{r summarise-as-nrow}
# count by aggregate function
receipt_tbl %>% summarise(n())
```

dbplyr 越しでは使えないメソッドもある. たとえば, `quantile` は `summarise` 以外では使えない.

```{r quantile-fails, error=TRUE}
# cause error
receipt_tbl %>%
    mutate(amount_quan1 = amount %>% quantile(probs = 0.25)) %>%
    head()
```

```{r quantile-works, error=TRUE}
# quantile works under summarise method
receipt_tbl %>%
    summarise(amount_quan1 = amount %>% quantile(probs = 0.25)) %>%
    head()
```

### データのダウンロード: `collect()`, `pull()`

実行結果を実データとして手元にダウンロードするには, `dplyr::collect()` を使うのが基本. これを実行した時点で DB との関連は切れて, ローカルの独立したデータとなる. 

```{r collect}
receipt_tbl %>%
    summarise(n()) %>%
    collect() # donwload data
```

見慣れた `tibble` が落ちてきたことが確認できる. 
ローカルに持ってくれば翻訳可能性問題は気にしなくてよくなる.

```{r quantile-in-local}
receipt_tbl %>%
    collect() %>%
    mutate(q1 = amount %>% quantile(probs = 0.25)) %>%
    head()
```

`dplyr::pull(.data, var = -1, name = NULL,...)` では特定の列をベクトルデータとしてダウンロードできる. これはスカラー値を得たいときに特に便利.
```{r pull}
receipt_tbl %>%
    summarise(q1 = amount %>% quantile(probs = 0.25)) %>%
    pull()
```

### SQL 文の取得: `show_query()`, `sql_render()`

R 上の加工処理がどのような SQL クエリに翻訳されたかは `dbplyr::show_query()` によって調べることができる. 

```{r }
receipt_tbl %>%
    summarise(n()) %>%
    show_query()
```

この翻訳結果を文字列として得るには `show_query()` ではなく, `dbplyr::sql_render()` を使う. なお, 間に `collect()` を挟んだデータをこれらのメソッドに与えるとエラーになる.

```{r error-show-query, error=TRUE}
receipt_tbl %>%
    summarise(n()) %>%
    collect() %>%
    show_query() # error. can't trace back to a remote table
```

DB 上のテーブルとの関連を失ったデータを得る方法を SQL で表すことはできないという自然な挙動だ.

### データのアップロード

`collect()` とは反対に, ローカルの `tibble` や `data.frame` を DB に渡してテーブルとして保存する手段もある. `RPostgres::dbWriteTable()` を使うことを勧める.

```{r write-table}
receipt_tbl %>%
    head() %>%
    # download
    collect() %>%
    # and upload
    RPostgres::dbWriteTable(conn = con, name = "tmp", value = ., overwirte = TRUE, temporary = TRUE)
# show remote tables
con %>% DBI::dbListTables()
```

より手軽な類似の手段として, `dplyr::copy_to()` や `dpylr::copy_inline()` もある. しかし, これらはデモ以外の目的では積極的に使うべきではないと思う. なぜかと言うと, たとえば, `dpylr::copy_inline()` はリモートサーバー ( のメモリ領域?) にコネクションが切れるまでの間限定の temporary なテーブルを作るが, このテーブルを参照する temporary でないビューが作れてしまう. そして, 再接続後にこのビューを参照するとエラーになる. なんじゃそりゃ.

ただし, `dplyr::copy_to()` は `tbl_lazy` を簡単にテーブル化することができるので, その目的に限定すれば使い所はある.

`RPostgres::dbWriteTable()` でも temporary なテーブルは作成可能だが, それを参照したビューは接続解除と同時に消えるぶんマシである. というより, そもそもビューではなくて一時オブジェクトとして扱われているようだ. 本稿では `dpylr::copy_inline()` 等は避けて `RPostgres::dbWriteTable()` を使う. あまりドキュメント化されておらず厄介な部分なので, `DBI::dbListTables()` や `DBI::dbListObjects()`, または直接に SQL によって, 挙動の違いを一度比較してみることを勧めたい.

いずれにせよ, temporary なテーブルは上述のように厄介な挙動を取るので, 用が済んだら消した方が安全.

```{r clean-tmp-table, collapse=TRUE}
con %>% DBI::dbListTables()
if (DBI::dbExistsTable(con, "tmp")) {
    DBI::dbRemoveTable(con, "tmp")
}
con %>% DBI::dbListTables()
```


パッケージの解説はここで切り上げ, 本題のノックを倒す方に移る. 次章で, 上で得た `customer_tbl` 等の参照を使って, dplyr の文法でデータ加工処理を書いていく. その際, dbplyr の知識を明示的に使う機会は主に, 「翻訳問題回避のためにいつ `collect()` を使うか」という形で現れる. したがって, そこさえ抑えられていれば, ここで解説した内容の細部に拘らず先に進んで全く問題ない.

