[["index.html", "dbplyrでデータサイエンス100本ノック(構造化データ加工編). 1 About 1.1 概要 1.2 dbplyr とは 2 Preparation 3 Answers R-006 R-015 R-016 R-019 R-020 R-026 R-028 R-029 R-031 R-033 R-036 R-038 R-039 R-041 R-042 R-043 R-044 R-045 R-046 R-047 3.1 日付処理へのコメント R-052 R-053 R-054 R-055 R-056 R-057 R-058 R-059 R-060", " dbplyrでデータサイエンス100本ノック(構造化データ加工編). Shena 2022-06-26 1 About 1.1 概要 このドキュメントは, データサイエンス100本ノック（構造化データ加工編） を R で解いた記録. dbplyr パッケージを利用して, 手元にデータをダウンロードせず, できるだけローカルの計算資源に依存しない方法で同ノックを倒す. :::note info 全問の回答は載せていない. 特に, SQL の方が楽にできる問題はスキップしている. ::: 1.2 dbplyr とは 詳細は以下に貼る公式ドキュメントや解説記事に譲るとして, すごく大雑把に言うと, dbplyr とは, dplyr の文法で書いた加工処理を SQL クエリに翻訳して実行した結果を返してくれるパッケージ. Introduction to dbplyr 巨大なデータがSQLサーバーにあるときに、Rでどう立ち向かうかマニュアル：dbplyrパッケージを中心として 手元にデータをダウンロードしようとしなければ, SQL の場合と同様に, 計算コストの大半をサーバー側が持ってくれる. また, 慣れ親しんだ tidyverse パッケージ群のいくつかを使うことができる. そのようなパッケージ以外の利用には制限が課されるため, 手元のデータを (たとえば) dbplyr で加工する場合と比べると, 必然的に道具立ては少なくなる. 2 Preparation Postgres DB が立ててあると想定して, R から DB へ接続する. Introduction to dbplyr 記載の方法に従う. 絶対使うパッケージ達. 最初の3つはコネクションを確立するために, dplyr はテーブルへの参照を得るためにそれぞれ必要. library(&quot;DBI&quot;) library(&quot;RPostgreSQL&quot;) library(&quot;dbplyr&quot;) library(&quot;dplyr&quot;) R.version.string # R version ## [1] &quot;R version 4.2.0 (2022-04-22)&quot; packageVersion(&quot;DBI&quot;) ## [1] &#39;1.1.2&#39; packageVersion(&quot;RPostgreSQL&quot;) ## [1] &#39;0.7.3&#39; packageVersion(&quot;dbplyr&quot;) ## [1] &#39;2.1.1&#39; packageVersion(&quot;dplyr&quot;) ## [1] &#39;1.0.9&#39; まだしてなければ, Postgres を起動. sudo service postgresql start Introduction to dbplyr は, DB 接続のためのコードとして以下の例と注意を述べている: con &lt;- DBI::dbConnect( RPostgreSQL::PostgreSQL(), host = &quot;database.rstudio.com&quot;, user = &quot;your-name&quot;, password = rstudioapi::askForPassword(&quot;Database password&quot;) ) If you’re not using RStudio, you’ll need some other way to securely retrieve your password. You should never record it in your analysis scripts or type it into the console. Securing Credentials provides some best practices. これを踏まえると, 以下の接続方法は大変行儀が悪いが, どうせ localhost にこのノック限定で立てているDBだろうし, さっさと準備を終える意味でも, ここでは咎めないことにする. con &lt;- DBI::dbConnect( RPostgreSQL::PostgreSQL(), host = &quot;localhost&quot;, port = 5432, dbname = &quot;your-database-name&quot;, user = &quot;your-user&quot;, password = &quot;your-password&quot; ) 接続できたか確認. DBI::dbListTables(con) ## [1] &quot;customer&quot; &quot;category&quot; &quot;geocode&quot; &quot;product&quot; &quot;receipt&quot; &quot;store&quot; 各テーブルへの参照を取得. customer_tbl &lt;- dplyr::tbl(con, &quot;customer&quot;) category_tbl &lt;- dplyr::tbl(con, &quot;category&quot;) product_tbl &lt;- dplyr::tbl(con, &quot;product&quot;) receipt_tbl &lt;- dplyr::tbl(con, &quot;receipt&quot;) store_tbl &lt;- dplyr::tbl(con, &quot;store&quot;) ちゃんとクエリが飛ばせるかテスト. receipt_tbl %&gt;% filter(amount &gt;= 1000) %&gt;% head() ## # Source: lazy query [?? x 9] ## # Database: postgres 12.0.11 [@localhost:5432/knock100] ## sales_ymd sales_epoch store_cd receipt_no receipt_sub_no customer_id ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; ## 1 20181225 1545696000 S13020 1172 2 ZZ000000000000 ## 2 20180911 1536624000 S13018 1122 2 CS018205000001 ## 3 20170501 1493596800 S13004 1192 2 CS004415000232 ## 4 20170523 1495497600 S14028 1182 2 CS028415000203 ## 5 20180310 1520640000 S14028 112 1 ZZ000000000000 ## 6 20170516 1494892800 S14023 1102 1 CS023415000240 ## # … with 3 more variables: product_cd &lt;chr&gt;, quantity &lt;int&gt;, amount &lt;int&gt; この customer_tbl 等の参照を使って dplyr の文法でデータ加工処理を書いていく. 3 Answers 以下, ノックの設問とその回答を並べていく. 設問文は, 100本ノック本家から引用. R-006 レシート明細データ（df_receipt）から売上⽇（sales_ymd）、顧客（customer_id）、商品コード（product_cd）、売上数量（quantity）、売上⾦額（amount）の順に列を指定し、以下の全ての条件を満たすデータを抽出せよ。 - 顧客ID（customer_id）が“CS018205000001” - 売上⾦額（amount）が1,000以上または売上数量（quantity）が5以上 receipt_tbl %&gt;% filter(amount &gt;= 1000 || quantity &gt;= 5) %&gt;% filter(customer_id == &quot;CS018205000001&quot;) %&gt;% select(sales_ymd, customer_id, product_cd, quantity, amount) %&gt;% head() ## # Source: lazy query [?? x 5] ## # Database: postgres 12.0.11 [@localhost:5432/knock100] ## sales_ymd customer_id product_cd quantity amount ## &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 20180911 CS018205000001 P071401012 1 2200 ## 2 20180414 CS018205000001 P060104007 6 600 ## 3 20170614 CS018205000001 P050206001 5 990 ## 4 20190226 CS018205000001 P071401020 1 2200 ## 5 20180911 CS018205000001 P071401005 1 1100 R-015 顧客データ（df_customer）から、ステータスコード（status_cd）の先頭がアルファベットのA〜Fで始まり、末尾が数字の1〜9で終わるデータを全項⽬抽出し、10件表⽰せよ。 library(stringr) # use stringr::str_detect() customer_tbl %&gt;% filter(str_detect(status_cd, &quot;^[A-F].*[1-9]$&quot;)) %&gt;% head() ## # Source: lazy query [?? x 11] ## # Database: postgres 12.0.11 [@localhost:5432/knock100] ## customer_id customer_name gender_cd gender birth_day age postal_cd address ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;date&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 CS011215000… 芦田 沙耶 1 女性 1992-02-01 27 223-0062 神奈川… ## 2 CS022513000… 島村 貴美子 1 女性 1962-03-12 57 249-0002 神奈川… ## 3 CS001515000… 水野 陽子 9 不明 1960-11-29 58 144-0053 東京都… ## 4 CS013615000… 西脇 季衣 1 女性 1953-10-18 65 261-0026 千葉県… ## 5 CS020412000… 小宮 薫 1 女性 1974-05-21 44 174-0042 東京都… ## 6 CS001215000… 竹中 あさみ 1 女性 1990-07-25 28 146-0095 東京都… ## # … with 3 more variables: application_store_cd &lt;chr&gt;, application_date &lt;chr&gt;, ## # status_cd &lt;chr&gt; R-016 店舗データ（df_store）から、電話番号（tel_no）が3桁-3桁-4桁のデータを全項目表示せよ。 store_tbl %&gt;% filter(str_detect(tel_no, &quot;^\\\\d{3}-\\\\d{3}-\\\\d{4}$&quot;)) %&gt;% head() ## # Source: lazy query [?? x 10] ## # Database: postgres 12.0.11 [@localhost:5432/knock100] ## store_cd store_name prefecture_cd prefecture address address_kana tel_no ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 S12014 千草台店 12 千葉県 千葉県千葉… チバケンチ… 043-1… ## 2 S13002 国分寺店 13 東京都 東京都国分… トウキョウ… 042-1… ## 3 S14010 菊名店 14 神奈川県 神奈川県横… カナガワケ… 045-1… ## 4 S14033 阿久和店 14 神奈川県 神奈川県横… カナガワケ… 045-1… ## 5 S14036 相模原中央店 14 神奈川県 神奈川県相… カナガワケ… 042-1… ## 6 S14040 長津田店 14 神奈川県 神奈川県横… カナガワケ… 045-1… ## # … with 3 more variables: longitude &lt;dbl&gt;, latitude &lt;dbl&gt;, floor_area &lt;dbl&gt; R-019 レシート明細データ（df_receipt）に対し、1件あたりの売上金額（amount）が高い順にランクを付与し、先頭から10件表示せよ。項目は顧客ID（customer_id）、売上金額（amount）、付与したランクを表示させること。なお、売上金額（amount）が等しい場合は同一順位を付与するものとする。 receipt_tbl %&gt;% select(customer_id, amount) %&gt;% mutate(ranking = min_rank(desc(amount))) %&gt;% arrange(ranking) %&gt;% head() ## # Source: lazy query [?? x 3] ## # Database: postgres 12.0.11 [@localhost:5432/knock100] ## # Ordered by: ranking ## customer_id amount ranking ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 CS011415000006 10925 1 ## 2 ZZ000000000000 6800 2 ## 3 CS028605000002 5780 3 ## 4 ZZ000000000000 5480 4 ## 5 CS015515000034 5480 4 ## 6 ZZ000000000000 5480 4 R-020 レシート明細データ（df_receipt）に対し、1件あたりの売上金額（amount）が高い順にランクを付与し、先頭から10件表示せよ。項目は顧客ID（customer_id）、売上金額（amount）、付与したランクを表示させること。なお、売上金額（amount）が等しい場合でも別順位を付与すること。 receipt_tbl %&gt;% select(customer_id, amount) %&gt;% mutate(ranking = row_number(desc(amount))) %&gt;% arrange(ranking) %&gt;% head() ## # Source: lazy query [?? x 3] ## # Database: postgres 12.0.11 [@localhost:5432/knock100] ## # Ordered by: ranking ## customer_id amount ranking ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 CS011415000006 10925 1 ## 2 ZZ000000000000 6800 2 ## 3 CS028605000002 5780 3 ## 4 ZZ000000000000 5480 4 ## 5 CS015515000034 5480 5 ## 6 ZZ000000000000 5480 6 R-026 レシート明細データ（df_receipt）に対し、顧客ID（customer_id）ごとに最も新しい売上年⽉⽇（sales_ymd）と古い売上年⽉⽇を求め、両者が異なるデータを10件表⽰せよ。 receipt_tbl %&gt;% group_by(customer_id) %&gt;% summarise(latest_ymd = max(sales_ymd, na.rm = TRUE), oldest_ymd = min(sales_ymd, na.rm = TRUE)) %&gt;% filter(latest_ymd != oldest_ymd) %&gt;% head() ## # Source: lazy query [?? x 3] ## # Database: postgres 12.0.11 [@localhost:5432/knock100] ## customer_id latest_ymd oldest_ymd ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 CS029212000033 20180621 20170318 ## 2 CS007515000119 20190511 20170201 ## 3 CS034515000123 20190708 20170527 ## 4 CS026414000014 20190720 20170718 ## 5 CS010515000082 20181204 20180518 ## 6 CS019315000045 20170920 20170423 R-028 レシート明細データ（df_receipt）に対し、店舗コード（store_cd）ごとに売上額 （amount）の中央値を計算し、降順でTOP5を表示せよ。 receipt_tbl %&gt;% group_by(store_cd) %&gt;% summarise(amount = median(amount, na.rm = TRUE)) %&gt;% arrange(desc(amount)) %&gt;% head() ## # Source: lazy query [?? x 2] ## # Database: postgres 12.0.11 [@localhost:5432/knock100] ## # Ordered by: desc(amount) ## store_cd amount ## &lt;chr&gt; &lt;dbl&gt; ## 1 S13052 190 ## 2 S14010 188 ## 3 S14050 185 ## 4 S14040 180 ## 5 S13003 180 ## 6 S13018 180 R-029 レシート明細データ（df_receipt）に対し、店舗コード（store_cd）ごとに商品コード（product_cd）の最頻値を求め、10件表示させよ。 receipt_tbl %&gt;% group_by(store_cd, product_cd) %&gt;% summarise(count = n(), .groups = &quot;drop_last&quot;) %&gt;% filter(count == max(count, na.rm = TRUE)) %&gt;% head() ## # Source: lazy query [?? x 3] ## # Database: postgres 12.0.11 [@localhost:5432/knock100] ## # Groups: store_cd ## store_cd product_cd count ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 S12007 P060303001 72 ## 2 S12013 P060303001 107 ## 3 S12014 P060303001 65 ## 4 S12029 P060303001 92 ## 5 S12030 P060303001 115 ## 6 S13001 P060303001 67 R-031 レシート明細データ（df_receipt）に対し、店舗コード（store_cd）ごとに売上金額（amount）の標準偏差を計算し、降順で5件表示せよ。 receipt_tbl %&gt;% group_by(store_cd) %&gt;% summarise(sd = sd(amount, na.rm = TRUE)) %&gt;% arrange(desc(sd)) %&gt;% head() ## # Source: lazy query [?? x 2] ## # Database: postgres 12.0.11 [@localhost:5432/knock100] ## # Ordered by: desc(sd) ## store_cd sd ## &lt;chr&gt; &lt;dbl&gt; ## 1 S13052 665. ## 2 S14011 554. ## 3 S14034 545. ## 4 S13001 544. ## 5 S13015 544. ## 6 S13035 527. R-033 レシート明細データ（df_receipt）に対し、店舗コード（store_cd）ごとに売上金額（amount）の平均を計算し、330以上のものを抽出せよ。 receipt_tbl %&gt;% group_by(store_cd) %&gt;% summarise(total = mean(amount, na.rm = TRUE)) %&gt;% filter(total &gt;= 330) %&gt;% head() ## # Source: lazy query [?? x 2] ## # Database: postgres 12.0.11 [@localhost:5432/knock100] ## store_cd total ## &lt;chr&gt; &lt;dbl&gt; ## 1 S13052 403. ## 2 S13019 330. ## 3 S13003 351. ## 4 S14045 330. ## 5 S13004 331. ## 6 S13001 348. R-036 レシート明細データ（df_receipt）と店舗データ（df_store）を内部結合し、レシート明細データの全項目と店舗データの店舗名（store_name）を10件表示せよ。 inner_join(receipt_tbl, store_tbl, by = &quot;store_cd&quot;) %&gt;% head() ## # Source: lazy query [?? x 18] ## # Database: postgres 12.0.11 [@localhost:5432/knock100] ## sales_ymd sales_epoch store_cd receipt_no receipt_sub_no customer_id ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; ## 1 20181103 1541203200 S14006 112 1 CS006214000001 ## 2 20181118 1542499200 S13008 1132 2 CS008415000097 ## 3 20170712 1499817600 S14028 1102 1 CS028414000014 ## 4 20190205 1549324800 S14042 1132 1 ZZ000000000000 ## 5 20180821 1534809600 S14025 1102 2 CS025415000050 ## 6 20190605 1559692800 S13003 1112 1 CS003515000195 ## # … with 12 more variables: product_cd &lt;chr&gt;, quantity &lt;int&gt;, amount &lt;int&gt;, ## # store_name &lt;chr&gt;, prefecture_cd &lt;int&gt;, prefecture &lt;chr&gt;, address &lt;chr&gt;, ## # address_kana &lt;chr&gt;, tel_no &lt;chr&gt;, longitude &lt;dbl&gt;, latitude &lt;dbl&gt;, ## # floor_area &lt;dbl&gt; R-038 顧客データ（df_customer）とレシート明細データ（df_receipt）から、顧客ごとの売上金額合計を求め、10件表示せよ。ただし、売上実績がない顧客については売上金額を0として表示させること。また、顧客は性別コード（gender_cd）が女性（1）であるものを対象とし、非会員（顧客IDが“Z”から始まるもの）は除外すること。 customer_tbl %&gt;% filter(gender_cd == 1 &amp;&amp; !str_detect(customer_id, &quot;^Z&quot;)) %&gt;% left_join(receipt_tbl, by = &quot;customer_id&quot;) %&gt;% group_by(customer_id) %&gt;% summarise(amount = sum(amount) %&gt;% dplyr::coalesce(0)) %&gt;% arrange(desc(amount)) %&gt;% head() ## # Source: lazy query [?? x 2] ## # Database: postgres 12.0.11 [@localhost:5432/knock100] ## # Ordered by: desc(amount) ## customer_id amount ## &lt;chr&gt; &lt;dbl&gt; ## 1 CS017415000097 23086 ## 2 CS015415000185 20153 ## 3 CS031414000051 19202 ## 4 CS028415000007 19127 ## 5 CS010214000010 18585 ## 6 CS006515000023 18372 R-039 レシート明細データ（df_receipt）から、売上日数の多い顧客の上位20件を抽出したデータと、売上金額合計の多い顧客の上位20件を抽出したデータをそれぞれ作成し、さらにその2つを完全外部結合せよ。ただし、非会員（顧客IDが“Z”から始まるもの）は除外すること。 reciept_by_id &lt;- receipt_tbl %&gt;% filter(!str_detect(customer_id, &quot;^Z&quot;)) %&gt;% group_by(customer_id) days_top &lt;- reciept_by_id %&gt;% summarise(n_days = n_distinct(sales_ymd) %&gt;% dplyr::coalesce(0)) %&gt;% arrange(desc(n_days)) %&gt;% head(20) %&gt;% collect() amount_top &lt;- reciept_by_id %&gt;% summarise(amount = sum(amount) %&gt;% dplyr::coalesce(0)) %&gt;% arrange(desc(amount)) %&gt;% head(20) %&gt;% collect() days_top %&gt;% full_join(amount_top, by = &quot;customer_id&quot;) %&gt;% head() ## # A tibble: 6 × 3 ## customer_id n_days amount ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 CS040214000008 23 NA ## 2 CS015415000185 22 20153 ## 3 CS010214000010 22 18585 ## 4 CS028415000007 21 19127 ## 5 CS010214000002 21 NA ## 6 CS017415000097 20 23086 R-041 レシート明細データ（df_receipt）の売上金額（amount）を日付（sales_ymd）ごとに集計し、前回売上があった日からの売上金額増減を計算せよ。そして結果を10件表示せよ。 receipt_tbl %&gt;% group_by(sales_ymd) %&gt;% summarise(sales_today = sum(amount)) %&gt;% mutate(sales_yest = sales_today %&gt;% lag()) %&gt;% mutate(diff = sales_today - sales_yest) %&gt;% head() ## # Source: lazy query [?? x 4] ## # Database: postgres 12.0.11 [@localhost:5432/knock100] ## sales_ymd sales_today sales_yest diff ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 20190504 49561 NA NA ## 2 20180414 27599 49561 -21962 ## 3 20170416 16442 27599 -11157 ## 4 20190422 37044 16442 20602 ## 5 20190710 27796 37044 -9248 ## 6 20181027 28497 27796 701 R-042 レシート明細データ（df_receipt）の売上金額（amount）を日付（sales_ymd）ごとに集計し、各日付のデータに対し、前回、前々回、3回前に売上があった日のデータを結合せよ。そして結果を10件表示せよ。 receipt_tbl %&gt;% group_by(sales_ymd) %&gt;% summarise(sales_daily = sum(sales_ymd)) %&gt;% mutate( across( sales_daily, list( lag_1 = ~ lag(.x, n = 1), lag_2 = ~ lag(.x, n = 2), lag_3 = ~ lag(.x, n = 3) ) ) ) %&gt;% head() ## # Source: lazy query [?? x 5] ## # Database: postgres 12.0.11 [@localhost:5432/knock100] ## sales_ymd sales_daily sales_daily_lag_1 sales_daily_lag_2 sales_daily_lag_3 ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 20190504 2382479472 NA NA NA ## 2 20180414 2118943470 2382479472 NA NA ## 3 20170416 1593462864 2118943470 2382479472 NA ## 4 20190422 2261327264 1593462864 2118943470 2382479472 ## 5 20190710 2059452420 2261327264 1593462864 2118943470 ## 6 20181027 1836473457 2059452420 2261327264 1593462864 R-043 レシート明細データ（df_receipt）と顧客データ（df_customer）を結合し、性別コード（gender_cd）と年代（ageから計算）ごとに売上金額（amount）を合計した売上サマリデータを作成せよ。性別コードは0が男性、1が女性、9が不明を表すものとする。 ただし、項目構成は年代、女性の売上金額、男性の売上金額、性別不明の売上金額の4項目とすること（縦に年代、横に性別のクロス集計）。また、年代は10歳ごとの階級とすること。 receipt_tbl %&gt;% inner_join(customer_tbl, by = &quot;customer_id&quot;) %&gt;% mutate(generation = age - age %% 10) %&gt;% group_by(generation, gender_cd) %&gt;% summarise(sales_amount = amount %&gt;% sum(), .groups = &quot;drop&quot;) %&gt;% tidyr::pivot_wider( names_from = gender_cd, names_prefix = &quot;sales&quot;, values_from = sales_amount, values_fill = 0 ) %&gt;% rename( sales_male = sales0, sales_female = sales1, sales_other = sales9 ) -&gt; sales_summary sales_summary ## # Source: lazy query [?? x 4] ## # Database: postgres 12.0.11 [@localhost:5432/knock100] ## generation sales_male sales_female sales_other ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 10 1591 149836 4317 ## 2 20 72940 1363724 44328 ## 3 30 177322 693047 50441 ## 4 40 19355 9320791 483512 ## 5 50 54320 6685192 342923 ## 6 60 272469 987741 71418 ## 7 70 13435 29764 2427 ## 8 80 46360 262923 5111 ## 9 90 0 6260 0 R-044 043で作成した売上サマリデータ（df_sales_summary）は性別の売上を横持ちさせたものであった。このデータから性別を縦持ちさせ、年代、性別コード、売上金額の3項目に変換せよ。ただし、性別コードは男性を“00”、女性を“01”、不明を“99”とする sales_summary %&gt;% rename(&quot;00&quot; = sales_male, &quot;01&quot; = sales_female, &quot;99&quot; = sales_other) %&gt;% tidyr::pivot_longer( cols = -generation, names_to = &quot;gender_cd&quot;, values_to = &quot;sales_amount&quot; ) %&gt;% head() ## # Source: lazy query [?? x 3] ## # Database: postgres 12.0.11 [@localhost:5432/knock100] ## generation gender_cd sales_amount ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 10 00 1591 ## 2 20 00 72940 ## 3 30 00 177322 ## 4 40 00 19355 ## 5 50 00 54320 ## 6 60 00 272469 R-045 顧客データ（df_customer）の生年月日（birth_day）は日付型でデータを保有している。これをYYYYMMDD形式の文字列に変換し、顧客ID（customer_id）とともに10件表示せよ。 library(stringr) # use stringr::str_replace_all() customer_tbl %&gt;% transmute( customer_id, date = birth_day %&gt;% as.character() %&gt;% str_replace_all(pattern = &quot;-&quot;, replacement = &quot;&quot;) ) %&gt;% head() ## # Source: lazy query [?? x 2] ## # Database: postgres 12.0.11 [@localhost:5432/knock100] ## customer_id date ## &lt;chr&gt; &lt;chr&gt; ## 1 CS021313000114 19810429 ## 2 CS037613000071 19520401 ## 3 CS031415000172 19761004 ## 4 CS028811000001 19330327 ## 5 CS001215000145 19950329 ## 6 CS020401000016 19740915 R-046 顧客データ（df_customer）の申し込み日（application_date）はYYYYMMDD形式の文字列型でデータを保有している。これを日付型に変換し、顧客ID（customer_id）とともに10件表示せよ。 customer_tbl %&gt;% transmute(customer_id, application_date = as.Date(application_date)) %&gt;% head() ## # Source: lazy query [?? x 2] ## # Database: postgres 12.0.11 [@localhost:5432/knock100] ## customer_id application_date ## &lt;chr&gt; &lt;date&gt; ## 1 CS021313000114 2015-09-05 ## 2 CS037613000071 2015-04-14 ## 3 CS031415000172 2015-05-29 ## 4 CS028811000001 2016-01-15 ## 5 CS001215000145 2017-06-05 ## 6 CS020401000016 2015-02-25 R-047 レシート明細データ（df_receipt）の売上日（sales_ymd）はYYYYMMDD形式の数値型でデータを保有している。これを日付型に変換し、レシート番号(receipt_no)、レシートサブ番号（receipt_sub_no）とともに10件表示せよ。 receipt_tbl %&gt;% transmute( sales_date = sales_ymd %&gt;% as.character() %&gt;% as.Date(), receipt_no, receipt_sub_no ) %&gt;% head() ## # Source: lazy query [?? x 3] ## # Database: postgres 12.0.11 [@localhost:5432/knock100] ## sales_date receipt_no receipt_sub_no ## &lt;date&gt; &lt;int&gt; &lt;int&gt; ## 1 2018-11-03 112 1 ## 2 2018-11-18 1132 2 ## 3 2017-07-12 1102 1 ## 4 2019-02-05 1132 1 ## 5 2018-08-21 1102 2 ## 6 2019-06-05 1112 1 3.1 日付処理へのコメント 日付処理は SQL で書いた方が遥かに楽なので, R にこだわる必要なし. R で日付を扱うパッケージとしては lubridate などがあるが, dbplyr 越しには使えないのでここでは書かない. というわけで R-048 から R-051 はスキップ. R-052 レシート明細データ（df_receipt）の売上金額（amount）を顧客ID（customer_id）ごとに合計の上、売上金額合計に対して2,000円以下を0、2,000円より大きい金額を1に二値化し、顧客ID、売上金額合計とともに10件表示せよ。ただし、顧客IDが“Z”から始まるのものは非会員を表すため、除外して計算すること。 library(stringr) # use stringr::str_detect() receipt_tbl %&gt;% filter(!str_detect(customer_id, &quot;^Z&quot;)) %&gt;% group_by(customer_id) %&gt;% summarise(amount = sum(amount, na.rm = TRUE)) %&gt;% mutate(amount_over_2000 = if_else(amount &gt; 2000, 1, 0)) %&gt;% head() ## # Source: lazy query [?? x 3] ## # Database: postgres 12.0.11 [@localhost:5432/knock100] ## customer_id amount amount_over_2000 ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 CS001311000059 2302 1 ## 2 CS004614000122 248 0 ## 3 CS003512000043 298 0 ## 4 CS011615000061 246 0 ## 5 CS029212000033 3604 1 ## 6 CS007515000119 7157 1 R-053 顧客データ（df_customer）の郵便番号（postal_cd）に対し、東京（先頭3桁が100〜209のもの）を1、それ以外のものを0に二値化せよ。さらにレシート明細データ（df_receipt）と結合し、全期間において売上実績のある顧客数を、作成した二値ごとにカウントせよ。 customer_tbl %&gt;% mutate( is_tokyo = dplyr::between(substr(postal_cd, 1, 3) %&gt;% as.integer(), 100, 209) %&gt;% if_else(1, 0) ) %&gt;% inner_join(receipt_tbl, by = &quot;customer_id&quot;) %&gt;% group_by(is_tokyo) %&gt;% summarise(amount = n_distinct(customer_id)) %&gt;% head() ## # Source: lazy query [?? x 2] ## # Database: postgres 12.0.11 [@localhost:5432/knock100] ## is_tokyo amount ## &lt;dbl&gt; &lt;dbl&gt; ## 1 0 3906 ## 2 1 4400 R-054 顧客データ（df_customer）の住所（address）は、埼玉県、千葉県、東京都、神奈川県のいずれかとなっている。都道府県毎にコード値を作成し、顧客ID、住所とともに10件表示せよ。値は埼玉県を11、千葉県を12、東京都を13、神奈川県を14とすること。 pref_vec &lt;- c(&quot;埼玉県&quot;, &quot;千葉県&quot;, &quot;東京都&quot;, &quot;神奈川&quot;) pref_map &lt;- function(str) which(str == pref_vec) + 10 %&gt;% as.integer() customer_tbl %&gt;% select(customer_id, address) %&gt;% mutate(pref_code = substr(address, 1, 3)) %&gt;% collect() %&gt;% mutate( across( .cols = pref_code, .fns = ~ purrr::map_dbl(.x, pref_map) ) ) %&gt;% head() ## # A tibble: 6 × 3 ## customer_id address pref_code ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 CS021313000114 神奈川県伊勢原市粟窪********** 14 ## 2 CS037613000071 東京都江東区南砂********** 13 ## 3 CS031415000172 東京都渋谷区代々木********** 13 ## 4 CS028811000001 神奈川県横浜市泉区和泉町********** 14 ## 5 CS001215000145 東京都大田区仲六郷********** 13 ## 6 CS020401000016 東京都板橋区若木********** 13 R-055 レシート明細（df_receipt）データの売上金額（amount）を顧客ID（customer_id）ごとに合計し、その合計金額の四分位点を求めよ。その上で、顧客ごとの売上金額合計に対して以下の基準でカテゴリ値を作成し、顧客ID、売上金額合計とともに10件表示せよ。カテゴリ値は順に1〜4とする。 最小値以上第1四分位未満: 1を付与 第1四分位以上第2四分位未満: 2を付与 第2四分位以上第3四分位未満: 3を付与 第3四分位以上: 4を付与 公式回答のように case_when で場合分けするのが素直なやり方だが, カテゴリ数が増えたとき非常に冗長なコードとなる. collect()を使ってもよいなら, つまり, group_by(customer_id) によってデータが十分に小さくなっているなら, 以下のような書き方もできる. なぜ collect() が必要かと言うと, dbplyr が対応する SQL コードを生成する際に, quantile 関数の probs 引数の次元が2以上の場合を処理できないから. receipt_tbl %&gt;% group_by(customer_id) %&gt;% summarise(amount = sum(amount)) %&gt;% collect() %&gt;% mutate(pct_group = amount) %&gt;% mutate( across( .cols = pct_group, .fns = function(cls) { q &lt;- quantile(cls, probs = c(0.25, 0.5, 0.75, 1.0)) purrr::map_int(cls, ~ which(.x &lt;= q) %&gt;% min()) } ) ) %&gt;% head() ## # A tibble: 6 × 3 ## customer_id amount pct_group ## &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; ## 1 CS001311000059 2302 3 ## 2 CS004614000122 248 1 ## 3 CS003512000043 298 1 ## 4 CS011615000061 246 1 ## 5 CS029212000033 3604 3 ## 6 CS007515000119 7157 4 R-056 顧客データ（df_customer）の年齢（age）をもとに10歳刻みで年代を算出し、顧客ID（customer_id）、生年月日（birth_day）とともに10件表示せよ。ただし、60歳以上は全て60歳代とすること。年代を表すカテゴリ名は任意とする。 customer_tbl %&gt;% mutate(generation = if_else(age &gt;= 60, 60, age - age %% 10)) -&gt; customer_generation customer_generation %&gt;% select(customer_id, birth_day, generation) %&gt;% head() ## # Source: lazy query [?? x 3] ## # Database: postgres 12.0.11 [@localhost:5432/knock100] ## customer_id birth_day generation ## &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; ## 1 CS021313000114 1981-04-29 30 ## 2 CS037613000071 1952-04-01 60 ## 3 CS031415000172 1976-10-04 40 ## 4 CS028811000001 1933-03-27 60 ## 5 CS001215000145 1995-03-29 20 ## 6 CS020401000016 1974-09-15 40 R-057 056の抽出結果と性別コード（gender_cd）により、新たに性別×年代の組み合わせを表すカテゴリデータを作成し、10件表示せよ。組み合わせを表すカテゴリの値は任意とする。 customer_generation %&gt;% mutate(gender_generation = gender_cd + generation) %&gt;% select( customer_id, gender_cd, gender, age, generation, gender_generation ) %&gt;% head() ## # Source: lazy query [?? x 6] ## # Database: postgres 12.0.11 [@localhost:5432/knock100] ## customer_id gender_cd gender age generation gender_generation ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 CS021313000114 1 女性 37 30 31 ## 2 CS037613000071 9 不明 66 60 69 ## 3 CS031415000172 1 女性 42 40 41 ## 4 CS028811000001 1 女性 86 60 61 ## 5 CS001215000145 1 女性 24 20 21 ## 6 CS020401000016 0 男性 44 40 40 R-058 顧客データ（df_customer）の性別コード（gender_cd）をダミー変数化し、顧客ID（customer_id）とともに10件表示せよ。 customer_tbl %&gt;% select(customer_id, gender_cd) %&gt;% mutate(value = 1) %&gt;% tidyr::pivot_wider( names_from = gender_cd, names_prefix = &quot;gender_cd&quot;, values_from = value, values_fill = 0 ) ## # Source: lazy query [?? x 4] ## # Database: postgres 12.0.11 [@localhost:5432/knock100] ## customer_id gender_cd0 gender_cd9 gender_cd1 ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 CS001105000001 1 0 0 ## 2 CS001112000009 0 0 1 ## 3 CS001112000019 0 0 1 ## 4 CS001112000021 0 0 1 ## 5 CS001112000023 0 0 1 ## 6 CS001112000024 0 0 1 ## 7 CS001112000029 0 0 1 ## 8 CS001112000030 0 0 1 ## 9 CS001113000004 0 0 1 ## 10 CS001113000010 0 0 1 ## # … with more rows R-059 レシート明細データ（df_receipt）の売上金額（amount）を顧客ID（customer_id）ごとに合計し、売上金額合計を平均0、標準偏差1に標準化して顧客ID、売上金額合計とともに10件表示せよ。標準化に使用する標準偏差は、分散の平方根、もしくは不偏分散の平方根のどちらでも良いものとする。ただし、顧客IDが“Z”から始まるのものは非会員を表すため、除外して計算すること。 scale 関数を dbplyr 越しに使えないので, mean と sd を使ってベタ書きする. library(stringr) # stringr::str_detect() receipt_tbl %&gt;% filter(!str_detect(customer_id, &quot;^Z&quot;)) %&gt;% group_by(customer_id) %&gt;% summarise(amount = sum(amount, na.rm = TRUE)) %&gt;% mutate(std_amount = (amount - mean(amount)) / sd(amount)) %&gt;% head() ## # Source: lazy query [?? x 3] ## # Database: postgres 12.0.11 [@localhost:5432/knock100] ## customer_id amount std_amount ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 CS001311000059 2302 -0.0903 ## 2 CS004614000122 248 -0.845 ## 3 CS003512000043 298 -0.827 ## 4 CS011615000061 246 -0.846 ## 5 CS029212000033 3604 0.388 ## 6 CS007515000119 7157 1.69 collect() していいなら, scale 関数を使って公式回答のように書ける. library(stringr) # stringr::str_detect() receipt_tbl %&gt;% filter(!str_detect(customer_id, &quot;^Z&quot;)) %&gt;% group_by(customer_id) %&gt;% summarise(amount = sum(amount, na.rm = TRUE)) %&gt;% collect() %&gt;% mutate(std_amount = scale(amount, center = TRUE, scale = TRUE)) %&gt;% head() ## # A tibble: 6 × 3 ## customer_id amount std_amount[,1] ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 CS001311000059 2302 -0.0903 ## 2 CS004614000122 248 -0.845 ## 3 CS003512000043 298 -0.827 ## 4 CS011615000061 246 -0.846 ## 5 CS029212000033 3604 0.388 ## 6 CS007515000119 7157 1.69 R-060 レシート明細データ（df_receipt）の売上金額（amount）を顧客ID（customer_id）ごとに合計し、売上金額合計を最小値0、最大値1に正規化して顧客ID、売上金額合計とともに10件表示せよ。ただし、顧客IDが“Z”から始まるのものは非会員を表すため、除外して計算すること。 library(stringr) # stringr::str_detect() receipt_tbl %&gt;% filter(!str_detect(customer_id, &quot;^Z&quot;)) %&gt;% group_by(customer_id) %&gt;% summarise(amount = sum(amount, na.rm = TRUE)) %&gt;% mutate(relative_pos = as.numeric((amount - min(amount))) / (max(amount) - min(amount))) %&gt;% head(10) ## # Source: lazy query [?? x 3] ## # Database: postgres 12.0.11 [@localhost:5432/knock100] ## customer_id amount relative_pos ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 CS001311000059 2302 0.0970 ## 2 CS004614000122 248 0.00773 ## 3 CS003512000043 298 0.00991 ## 4 CS011615000061 246 0.00765 ## 5 CS029212000033 3604 0.154 ## 6 CS007515000119 7157 0.308 ## 7 CS034515000123 3699 0.158 ## 8 CS004315000058 490 0.0182 ## 9 CS026414000014 6671 0.287 ## 10 CS001615000099 768 0.0303 "]]
