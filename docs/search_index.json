[["index.html", "dbplyrでデータサイエンス100本ノック(構造化データ加工編). 1 前置き 1.1 概要 1.2 dbplyr とは 2 準備と予備知識 2.1 R から DB への接続 2.2 dbplyr ミニハンズオン 3 回答例 R-006 R-015 R-016 R-019 R-020 R-026 R-028 R-029 R-031 R-033 R-036 R-038 R-039 R-041 R-042 R-043 R-044 R-045 R-046 R-047 日付処理へのコメント R-052 R-053 R-054 R-055 R-056 R-057 R-058 R-059 R-060 R-069 R-070 R-074 R-078 R-079 R-080 R-081 R-083 R-084 R-087 R-089 R-091 4 References: dbplyr, DBI, RPostgres 参考資料", " dbplyrでデータサイエンス100本ノック(構造化データ加工編). Shena 2022-07-03 1 前置き 1.1 概要 このドキュメントは, データサイエンス100本ノック（構造化データ加工編） を WSL2 + Ubuntu20.04 + R で解いた記録. dbplyr パッケージを利用して, 極力データを手元にダウンロードせずに, DB 上の操作だけで完結する手段をとる. なお, 全問の回答は載せていない. 特に, SQL の方が楽にできる問題や公式回答と似た回答になった問題の多くはスキップしている. 以下の記事は大変参考にさせていただきました. 公開に感謝します. 【R】データサイエンス100本ノック（構造化データ加工編）をtidyverseでやった 1.2 dbplyr とは 詳細は 4 - References の文献に譲り, ここでは大雑把に書く. dbplyr とは, dplyr の文法で書いたデータ加工処理を接続先に合わせた適切な SQL クエリに翻訳し, DBI (Database Interface) などのバックエンドとして働くパッケージと連携して, その SQL の実行結果を返してくれるパッケージ. dbplyr は SQL の SELECT 文に相当する処理のみを翻訳する. 以下は, dbplyr を利用する際の典型的な作業フローの概要. サンプルコードは 2 - 準備と予備知識にある. 接続: DBI と 接続先 DB に対応した専用パッケージ (e.g., RPostgres, RSQLite) で接続を確立 テーブルへの参照取得: 接続した DB 上のテーブルへの参照を取得 処理内容の作成: 参照先のテーブルに対して, dplyr の文法でデータ処理加工を書く SQLへの翻訳: dbplyr がその処理内容を SQL に変換する SQL の実行: DBI 等のバックエンドパッケージがその SQL を実行し, 結果への参照を返す 直接 SQL を書くのではなく dbplyr を使うメリットとしては, SQL の方言に関わらず, 統一的な書き方ができる 多くの場合, コードがより簡潔になる R - SQL 間の言語またぎが起こりづらい などが挙げられる. 一方, デメリットとしては, 利用するパッケージがいくつかあるので, それについての知識が追加で必要 SQL に比べて文献が少ない 翻訳可能な R コード群を整理するまでに試行錯誤が必要 初等的と思える処理でも翻訳できないことがある などがある. ただし, これらの点, 特に1, 2点目は, 100本ノックを倒す目的の範囲内ならばほとんど問題にならない. 厄介なのは後半の2点である. この翻訳可能性問題を回避するために, サイズが十分小さくなるまで加工したデータをローカルマシンにダウンロードし, 通常の R での加工処理に帰着させる方法をよく取る. この場合, 上述の作業フローに以下の手続きが追加される. データのダウンロード: DB 上のデータを dbplyr で手元にダウンロードする ローカルでのデータ加工: ダウンロードデータを通常のRデータとしてさらに加工する(パッケージ使い放題) データのアップロード (optional) : DBI などのバックエンドパッケージを使ってそのデータを DB 上にアップロードする 2 準備と予備知識 Postgres DB がどこかに立ててあると想定して, R から DB へ接続する. その後, DB 上のデータを dbplyr で扱うための最低限の知識をレビューする. チュートリアルとしては, 以下も参考になる. 必要に応じて参照されたい. Introduction to dbplyr 巨大なデータがSQLサーバーにあるときに、Rでどう立ち向かうかマニュアル：dbplyrパッケージを中心として 2.1 R から DB への接続 Introduction to dbplyr 記載の方法に従う. 必須パッケージ達. 最初の2つは DB への接続用. R.version.string # R version ## [1] &quot;R version 4.2.0 (2022-04-22)&quot; packageVersion(&quot;RPostgres&quot;) ## [1] &#39;1.4.4.9000&#39; packageVersion(&quot;DBI&quot;) ## [1] &#39;1.1.3&#39; packageVersion(&quot;dbplyr&quot;) ## [1] &#39;2.2.1&#39; packageVersion(&quot;dplyr&quot;) ## [1] &#39;1.0.9&#39; まだしてなければ, bash を叩いて Postgres を起動. sudo service postgresql start Introduction to dbplyr は, DB 接続のためのコードとして以下の例と注意を述べている: (この例では RPostgreSQL::PostgreSQL() とされていることに注意.) con &lt;- DBI::dbConnect( drv = RPostgreSQL::PostgreSQL(), host = &quot;database.rstudio.com&quot;, user = &quot;your-name&quot;, password = rstudioapi::askForPassword(&quot;Database password&quot;) ) If you’re not using RStudio, you’ll need some other way to securely retrieve your password. You should never record it in your analysis scripts or type it into the console. Securing Credentials provides some best practices. これを踏まえると, 以下の接続方法は大変行儀が悪いが, 今回はどうせ localhost にこのノック限定で立てている DB だろうから, ここでは咎めないことにする. con &lt;- DBI::dbConnect( drv = RPostgres::Postgres(), host = &quot;localhost&quot;, port = 5432, dbname = &quot;your-database-name&quot;, user = &quot;your-user&quot;, password = &quot;your-password&quot; ) 接続できたか確認. DBI::dbListTables(con) ## [1] &quot;customer&quot; &quot;category&quot; &quot;geocode&quot; &quot;product&quot; &quot;receipt&quot; &quot;store&quot; 2.2 dbplyr ミニハンズオン 1.2 で述べた作業フローに挙げた項目を, サンプルコードを示す. 知識習得の目的をノックを倒すことの限定すれば, テーブルの参照の取得方法と collect() の使い方が分かれば問題ない. より詳細を知るには, 4 References に挙げた文献が有用. まずは, DB 上のテーブルへの参照を取得しよう. 2.2.1 テーブルへの参照 customer_tbl &lt;- dplyr::tbl(con, &quot;customer&quot;) category_tbl &lt;- dplyr::tbl(con, &quot;category&quot;) product_tbl &lt;- dplyr::tbl(con, &quot;product&quot;) receipt_tbl &lt;- dplyr::tbl(con, &quot;receipt&quot;) store_tbl &lt;- dplyr::tbl(con, &quot;store&quot;) customer_tbl %&gt;% class() ## [1] &quot;tbl_PqConnection&quot; &quot;tbl_dbi&quot; &quot;tbl_sql&quot; &quot;tbl_lazy&quot; ## [5] &quot;tbl&quot; なお, この参照は DBI::dbDisconnect() によって失われる. 次に, この参照を使ってクエリが飛ばせるかテスト. receipt_tbl %&gt;% filter(amount &gt;= 1000) %&gt;% head() ## # Source: SQL [6 x 9] ## # Database: postgres [guest@localhost:5432/knock100] ## sales_ymd sales_epoch store_cd receipt_no receipt_sub_no customer_id ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; ## 1 20181225 1545696000 S13020 1172 2 ZZ000000000000 ## 2 20180911 1536624000 S13018 1122 2 CS018205000001 ## 3 20170501 1493596800 S13004 1192 2 CS004415000232 ## 4 20170523 1495497600 S14028 1182 2 CS028415000203 ## 5 20180310 1520640000 S14028 112 1 ZZ000000000000 ## 6 20170516 1494892800 S14023 1102 1 CS023415000240 ## # … with 3 more variables: product_cd &lt;chr&gt;, quantity &lt;int&gt;, amount &lt;int&gt; このとき返されるのは実データとしての tibble ではなく, 入力元のリモートテーブルと同じ tbl_dbi オブジェクトである. dbplyr の文脈では tbl_lazy と呼ばれることも多いようだ. receipt_tbl %&gt;% filter(amount &gt;= 1000) %&gt;% head() %&gt;% class() ## [1] &quot;tbl_PqConnection&quot; &quot;tbl_dbi&quot; &quot;tbl_sql&quot; &quot;tbl_lazy&quot; ## [5] &quot;tbl&quot; 2.2.2 利用できない R 関数例 実データではないので, tbl_dbi %&gt;% nrow() は常に NA になる. receipt_tbl %&gt;% nrow() ## [1] NA 代替手段としては, summarise で数えてもらえばよい. # count by aggregate function receipt_tbl %&gt;% summarise(n()) ## # Source: SQL [1 x 1] ## # Database: postgres [guest@localhost:5432/knock100] ## `n()` ## &lt;int64&gt; ## 1 104681 dbplyr 越しでは使えないメソッドもある. たとえば, quantile は summarise 以外では使えない. # cause error receipt_tbl %&gt;% mutate(amount_quan1 = amount %&gt;% quantile(probs = 0.25)) %&gt;% head() ## Error: Failed to prepare query: ERROR: OVER is not supported for ordered-set aggregate percentile_cont ## LINE 3: PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY &quot;amount&quot;) OVE... ## ^ # quantile works under summarise method receipt_tbl %&gt;% summarise(amount_quan1 = amount %&gt;% quantile(probs = 0.25)) %&gt;% head() ## # Source: SQL [1 x 1] ## # Database: postgres [guest@localhost:5432/knock100] ## amount_quan1 ## &lt;dbl&gt; ## 1 102 2.2.3 データのダウンロード: collect(), pull() 実行結果を実データとして手元にダウンロードするには, dplyr::collect() を使うのが基本. これを実行した時点で DB との関連は切れて, ローカルの独立したデータとなる. receipt_tbl %&gt;% summarise(n()) %&gt;% collect() # donwload data ## # A tibble: 1 × 1 ## `n()` ## &lt;int64&gt; ## 1 104681 見慣れた tibble が落ちてきたことが確認できる. ローカルに持ってくれば翻訳可能性問題は気にしなくてよくなる. receipt_tbl %&gt;% collect() %&gt;% mutate(q1 = amount %&gt;% quantile(probs = 0.25)) %&gt;% head() ## # A tibble: 6 × 10 ## sales_ymd sales_epoch store_cd receipt_no receipt_sub_no customer_id ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; ## 1 20181103 1541203200 S14006 112 1 CS006214000001 ## 2 20181118 1542499200 S13008 1132 2 CS008415000097 ## 3 20170712 1499817600 S14028 1102 1 CS028414000014 ## 4 20190205 1549324800 S14042 1132 1 ZZ000000000000 ## 5 20180821 1534809600 S14025 1102 2 CS025415000050 ## 6 20190605 1559692800 S13003 1112 1 CS003515000195 ## # … with 4 more variables: product_cd &lt;chr&gt;, quantity &lt;int&gt;, amount &lt;int&gt;, ## # q1 &lt;dbl&gt; dplyr::pull(.data, var = -1, name = NULL,...) では特定の列をベクトルデータとしてダウンロードできる. これはスカラー値を得たいときに特に便利. receipt_tbl %&gt;% summarise(q1 = amount %&gt;% quantile(probs = 0.25)) %&gt;% pull() ## [1] 102 2.2.4 SQL 文の取得: show_query(), sql_render() R 上の加工処理がどのような SQL クエリに翻訳されたかは dbplyr::show_query() によって調べることができる. receipt_tbl %&gt;% summarise(n()) %&gt;% show_query() ## &lt;SQL&gt; ## SELECT COUNT(*) AS &quot;n()&quot; ## FROM &quot;receipt&quot; この翻訳結果を文字列として得るには show_query() ではなく, dbplyr::sql_render() を使う. なお, 間に collect() を挟んだデータをこれらのメソッドに与えるとエラーになる. receipt_tbl %&gt;% summarise(n()) %&gt;% collect() %&gt;% show_query() # error. can&#39;t trace back to a remote table ## Error in UseMethod(&quot;show_query&quot;): no applicable method for &#39;show_query&#39; applied to an object of class &quot;c(&#39;tbl_df&#39;, &#39;tbl&#39;, &#39;data.frame&#39;)&quot; DB 上のテーブルとの関連を失ったデータを得る方法を SQL で表すことはできないという自然な挙動だ. 2.2.5 データのアップロード collect() とは反対に, ローカルの tibble や data.frame を DB に渡してテーブルとして保存する手段もある. RPostgres::dbWriteTable() を使うことを勧める. receipt_tbl %&gt;% head() %&gt;% # download collect() %&gt;% # and upload RPostgres::dbWriteTable(conn = con, name = &quot;tmp&quot;, value = ., overwirte = TRUE, temporary = TRUE) # show remote tables con %&gt;% DBI::dbListTables() ## [1] &quot;customer&quot; &quot;category&quot; &quot;geocode&quot; &quot;product&quot; &quot;receipt&quot; &quot;store&quot; &quot;tmp&quot; より手軽な類似の手段として, dplyr::copy_to() や dpylr::copy_inline() もある. しかし, これらはデモ以外の目的では積極的に使うべきではないと思う. なぜかと言うと, たとえば, dpylr::copy_inline() はリモートサーバー ( のメモリ領域?) にコネクションが切れるまでの間限定の temporary なテーブルを作るが, このテーブルを参照する temporary でないビューが作れてしまう. そして, 再接続後にこのビューを参照するとエラーになる. なんじゃそりゃ. ただし, dplyr::copy_to() は tbl_lazy を簡単にテーブル化することができるので, その目的に限定すれば使い所はある. RPostgres::dbWriteTable() でも temporary なテーブルは作成可能だが, それを参照したビューは接続解除と同時に消えるぶんマシである. というより, そもそもビューではなくて一時オブジェクトとして扱われているようだ. 本稿では dpylr::copy_inline() 等は避けて RPostgres::dbWriteTable() を使う. あまりドキュメント化されておらず厄介な部分なので, DBI::dbListTables() や DBI::dbListObjects(), または直接に SQL によって, 挙動の違いを一度比較してみることを勧めたい. いずれにせよ, temporary なテーブルは上述のように厄介な挙動を取るので, 用が済んだら消した方が安全. con %&gt;% DBI::dbListTables() ## [1] &quot;customer&quot; &quot;category&quot; &quot;geocode&quot; &quot;product&quot; &quot;receipt&quot; &quot;store&quot; &quot;tmp&quot; if (DBI::dbExistsTable(con, &quot;tmp&quot;)) { DBI::dbRemoveTable(con, &quot;tmp&quot;) } con %&gt;% DBI::dbListTables() ## [1] &quot;customer&quot; &quot;category&quot; &quot;geocode&quot; &quot;product&quot; &quot;receipt&quot; &quot;store&quot; パッケージの解説はここで切り上げ, 本題のノックを倒す方に移る. 次章で, 上で得た customer_tbl 等の参照を使って, dplyr の文法でデータ加工処理を書いていく. その際, dbplyr の知識を明示的に使う機会は主に, 「翻訳問題回避のためにいつ collect() を使うか」という形で現れる. したがって, そこさえ抑えられていれば, ここで解説した内容の細部に拘らず先に進んで全く問題ない. 3 回答例 以下, ノックの設問とその回答を並べていく. 設問文は, 100本ノック本家から引用. R-006 レシート明細データ（df_receipt）から売上⽇（sales_ymd）、顧客（customer_id）、商品コード（product_cd）、売上数量（quantity）、売上⾦額（amount）の順に列を指定し、以下の全ての条件を満たすデータを抽出せよ。 顧客ID（customer_id）が“CS018205000001” 売上⾦額（amount）が1,000以上または売上数量（quantity）が5以上 receipt_tbl %&gt;% filter(amount &gt;= 1000 || quantity &gt;= 5) %&gt;% filter(customer_id == &quot;CS018205000001&quot;) %&gt;% select(sales_ymd, customer_id, product_cd, quantity, amount) %&gt;% head() ## # Source: SQL [5 x 5] ## # Database: postgres [guest@localhost:5432/knock100] ## sales_ymd customer_id product_cd quantity amount ## &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 20180911 CS018205000001 P071401012 1 2200 ## 2 20180414 CS018205000001 P060104007 6 600 ## 3 20170614 CS018205000001 P050206001 5 990 ## 4 20190226 CS018205000001 P071401020 1 2200 ## 5 20180911 CS018205000001 P071401005 1 1100 R-015 顧客データ（df_customer）から、ステータスコード（status_cd）の先頭がアルファベットのA〜Fで始まり、末尾が数字の1〜9で終わるデータを全項⽬抽出し、10件表⽰せよ。 library(stringr) # use stringr::str_detect() customer_tbl %&gt;% filter(str_detect(status_cd, &quot;^[A-F].*[1-9]$&quot;)) %&gt;% head() ## # Source: SQL [6 x 11] ## # Database: postgres [guest@localhost:5432/knock100] ## customer_id customer_name gender_cd gender birth_day age postal_cd address ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;date&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 CS011215000… 芦田 沙耶 1 女性 1992-02-01 27 223-0062 神奈川… ## 2 CS022513000… 島村 貴美子 1 女性 1962-03-12 57 249-0002 神奈川… ## 3 CS001515000… 水野 陽子 9 不明 1960-11-29 58 144-0053 東京都… ## 4 CS013615000… 西脇 季衣 1 女性 1953-10-18 65 261-0026 千葉県… ## 5 CS020412000… 小宮 薫 1 女性 1974-05-21 44 174-0042 東京都… ## 6 CS001215000… 竹中 あさみ 1 女性 1990-07-25 28 146-0095 東京都… ## # … with 3 more variables: application_store_cd &lt;chr&gt;, application_date &lt;chr&gt;, ## # status_cd &lt;chr&gt; R-016 店舗データ（df_store）から、電話番号（tel_no）が3桁-3桁-4桁のデータを全項目表示せよ。 store_tbl %&gt;% filter(str_detect(tel_no, &quot;^\\\\d{3}-\\\\d{3}-\\\\d{4}$&quot;)) %&gt;% head() ## # Source: SQL [6 x 10] ## # Database: postgres [guest@localhost:5432/knock100] ## store_cd store_name prefecture_cd prefecture address address_kana tel_no ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 S12014 千草台店 12 千葉県 千葉県千葉… チバケンチ… 043-1… ## 2 S13002 国分寺店 13 東京都 東京都国分… トウキョウ… 042-1… ## 3 S14010 菊名店 14 神奈川県 神奈川県横… カナガワケ… 045-1… ## 4 S14033 阿久和店 14 神奈川県 神奈川県横… カナガワケ… 045-1… ## 5 S14036 相模原中央店 14 神奈川県 神奈川県相… カナガワケ… 042-1… ## 6 S14040 長津田店 14 神奈川県 神奈川県横… カナガワケ… 045-1… ## # … with 3 more variables: longitude &lt;dbl&gt;, latitude &lt;dbl&gt;, floor_area &lt;dbl&gt; R-019 レシート明細データ（df_receipt）に対し、1件あたりの売上金額（amount）が高い順にランクを付与し、先頭から10件表示せよ。項目は顧客ID（customer_id）、売上金額（amount）、付与したランクを表示させること。なお、売上金額（amount）が等しい場合は同一順位を付与するものとする。 receipt_tbl %&gt;% select(customer_id, amount) %&gt;% mutate(ranking = min_rank(desc(amount))) %&gt;% arrange(ranking) %&gt;% head() ## # Source: SQL [6 x 3] ## # Database: postgres [guest@localhost:5432/knock100] ## # Ordered by: ranking ## customer_id amount ranking ## &lt;chr&gt; &lt;int&gt; &lt;int64&gt; ## 1 CS011415000006 10925 1 ## 2 ZZ000000000000 6800 2 ## 3 CS028605000002 5780 3 ## 4 ZZ000000000000 5480 4 ## 5 CS015515000034 5480 4 ## 6 ZZ000000000000 5480 4 R-020 レシート明細データ（df_receipt）に対し、1件あたりの売上金額（amount）が高い順にランクを付与し、先頭から10件表示せよ。項目は顧客ID（customer_id）、売上金額（amount）、付与したランクを表示させること。なお、売上金額（amount）が等しい場合でも別順位を付与すること。 receipt_tbl %&gt;% select(customer_id, amount) %&gt;% mutate(ranking = row_number(desc(amount))) %&gt;% arrange(ranking) %&gt;% head() ## # Source: SQL [6 x 3] ## # Database: postgres [guest@localhost:5432/knock100] ## # Ordered by: ranking ## customer_id amount ranking ## &lt;chr&gt; &lt;int&gt; &lt;int64&gt; ## 1 CS011415000006 10925 1 ## 2 ZZ000000000000 6800 2 ## 3 CS028605000002 5780 3 ## 4 ZZ000000000000 5480 4 ## 5 CS015515000034 5480 5 ## 6 ZZ000000000000 5480 6 R-026 レシート明細データ（df_receipt）に対し、顧客ID（customer_id）ごとに最も新しい売上年⽉⽇（sales_ymd）と古い売上年⽉⽇を求め、両者が異なるデータを10件表⽰せよ。 receipt_tbl %&gt;% group_by(customer_id) %&gt;% summarise(latest_ymd = max(sales_ymd, na.rm = TRUE), oldest_ymd = min(sales_ymd, na.rm = TRUE)) %&gt;% filter(latest_ymd != oldest_ymd) %&gt;% head() ## # Source: SQL [6 x 3] ## # Database: postgres [guest@localhost:5432/knock100] ## customer_id latest_ymd oldest_ymd ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 CS029212000033 20180621 20170318 ## 2 CS007515000119 20190511 20170201 ## 3 CS034515000123 20190708 20170527 ## 4 CS026414000014 20190720 20170718 ## 5 CS010515000082 20181204 20180518 ## 6 CS019315000045 20170920 20170423 R-028 レシート明細データ（df_receipt）に対し、店舗コード（store_cd）ごとに売上額 （amount）の中央値を計算し、降順でTOP5を表示せよ。 receipt_tbl %&gt;% group_by(store_cd) %&gt;% summarise(amount = median(amount, na.rm = TRUE)) %&gt;% arrange(desc(amount)) %&gt;% head() ## # Source: SQL [6 x 2] ## # Database: postgres [guest@localhost:5432/knock100] ## # Ordered by: desc(amount) ## store_cd amount ## &lt;chr&gt; &lt;dbl&gt; ## 1 S13052 190 ## 2 S14010 188 ## 3 S14050 185 ## 4 S14040 180 ## 5 S13003 180 ## 6 S13018 180 R-029 レシート明細データ（df_receipt）に対し、店舗コード（store_cd）ごとに商品コード（product_cd）の最頻値を求め、10件表示させよ。 receipt_tbl %&gt;% group_by(store_cd, product_cd) %&gt;% summarise(count = n(), .groups = &quot;drop_last&quot;) %&gt;% filter(count == max(count, na.rm = TRUE)) %&gt;% head() ## # Source: SQL [6 x 3] ## # Database: postgres [guest@localhost:5432/knock100] ## # Groups: store_cd ## store_cd product_cd count ## &lt;chr&gt; &lt;chr&gt; &lt;int64&gt; ## 1 S12007 P060303001 72 ## 2 S12013 P060303001 107 ## 3 S12014 P060303001 65 ## 4 S12029 P060303001 92 ## 5 S12030 P060303001 115 ## 6 S13001 P060303001 67 R-031 レシート明細データ（df_receipt）に対し、店舗コード（store_cd）ごとに売上金額（amount）の標準偏差を計算し、降順で5件表示せよ。 receipt_tbl %&gt;% group_by(store_cd) %&gt;% summarise(sd = sd(amount, na.rm = TRUE)) %&gt;% arrange(desc(sd)) %&gt;% head() ## # Source: SQL [6 x 2] ## # Database: postgres [guest@localhost:5432/knock100] ## # Ordered by: desc(sd) ## store_cd sd ## &lt;chr&gt; &lt;dbl&gt; ## 1 S13052 665. ## 2 S14011 554. ## 3 S14034 545. ## 4 S13001 544. ## 5 S13015 544. ## 6 S13035 527. R-033 レシート明細データ（df_receipt）に対し、店舗コード（store_cd）ごとに売上金額（amount）の平均を計算し、330以上のものを抽出せよ。 receipt_tbl %&gt;% group_by(store_cd) %&gt;% summarise(total = mean(amount, na.rm = TRUE)) %&gt;% filter(total &gt;= 330) %&gt;% head() ## # Source: SQL [6 x 2] ## # Database: postgres [guest@localhost:5432/knock100] ## store_cd total ## &lt;chr&gt; &lt;dbl&gt; ## 1 S13052 403. ## 2 S13019 330. ## 3 S13003 351. ## 4 S14045 330. ## 5 S13004 331. ## 6 S13001 348. R-036 レシート明細データ（df_receipt）と店舗データ（df_store）を内部結合し、レシート明細データの全項目と店舗データの店舗名（store_name）を10件表示せよ。 inner_join(receipt_tbl, store_tbl, by = &quot;store_cd&quot;) %&gt;% head() ## # Source: SQL [6 x 18] ## # Database: postgres [guest@localhost:5432/knock100] ## sales_ymd sales_epoch store_cd receipt_no receipt_sub_no customer_id ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; ## 1 20181103 1541203200 S14006 112 1 CS006214000001 ## 2 20181118 1542499200 S13008 1132 2 CS008415000097 ## 3 20170712 1499817600 S14028 1102 1 CS028414000014 ## 4 20190205 1549324800 S14042 1132 1 ZZ000000000000 ## 5 20180821 1534809600 S14025 1102 2 CS025415000050 ## 6 20190605 1559692800 S13003 1112 1 CS003515000195 ## # … with 12 more variables: product_cd &lt;chr&gt;, quantity &lt;int&gt;, amount &lt;int&gt;, ## # store_name &lt;chr&gt;, prefecture_cd &lt;int&gt;, prefecture &lt;chr&gt;, address &lt;chr&gt;, ## # address_kana &lt;chr&gt;, tel_no &lt;chr&gt;, longitude &lt;dbl&gt;, latitude &lt;dbl&gt;, ## # floor_area &lt;dbl&gt; R-038 顧客データ（df_customer）とレシート明細データ（df_receipt）から、顧客ごとの売上金額合計を求め、10件表示せよ。ただし、売上実績がない顧客については売上金額を0として表示させること。また、顧客は性別コード（gender_cd）が女性（1）であるものを対象とし、非会員（顧客IDが“Z”から始まるもの）は除外すること。 customer_tbl %&gt;% filter(gender_cd == 1 &amp;&amp; !str_detect(customer_id, &quot;^Z&quot;)) %&gt;% left_join(receipt_tbl, by = &quot;customer_id&quot;) %&gt;% group_by(customer_id) %&gt;% summarise(amount = sum(amount) %&gt;% dplyr::coalesce(0)) %&gt;% arrange(desc(amount)) %&gt;% head() ## # Source: SQL [6 x 2] ## # Database: postgres [guest@localhost:5432/knock100] ## # Ordered by: desc(amount) ## customer_id amount ## &lt;chr&gt; &lt;dbl&gt; ## 1 CS017415000097 23086 ## 2 CS015415000185 20153 ## 3 CS031414000051 19202 ## 4 CS028415000007 19127 ## 5 CS010214000010 18585 ## 6 CS006515000023 18372 R-039 レシート明細データ（df_receipt）から、売上日数の多い顧客の上位20件を抽出したデータと、売上金額合計の多い顧客の上位20件を抽出したデータをそれぞれ作成し、さらにその2つを完全外部結合せよ。ただし、非会員（顧客IDが“Z”から始まるもの）は除外すること。 reciept_by_id &lt;- receipt_tbl %&gt;% filter(!str_detect(customer_id, &quot;^Z&quot;)) %&gt;% group_by(customer_id) days_top &lt;- reciept_by_id %&gt;% summarise(n_days = n_distinct(sales_ymd) %&gt;% dplyr::coalesce(0)) %&gt;% arrange(desc(n_days)) %&gt;% head(20) %&gt;% collect() amount_top &lt;- reciept_by_id %&gt;% summarise(amount = sum(amount) %&gt;% dplyr::coalesce(0)) %&gt;% arrange(desc(amount)) %&gt;% head(20) %&gt;% collect() days_top %&gt;% full_join(amount_top, by = &quot;customer_id&quot;) %&gt;% head() ## # A tibble: 6 × 3 ## customer_id n_days amount ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 CS040214000008 23 NA ## 2 CS015415000185 22 20153 ## 3 CS010214000010 22 18585 ## 4 CS028415000007 21 19127 ## 5 CS010214000002 21 NA ## 6 CS017415000097 20 23086 R-041 レシート明細データ（df_receipt）の売上金額（amount）を日付（sales_ymd）ごとに集計し、前回売上があった日からの売上金額増減を計算せよ。そして結果を10件表示せよ。 receipt_tbl %&gt;% group_by(sales_ymd) %&gt;% summarise(sales_today = sum(amount)) %&gt;% mutate(sales_yest = sales_today %&gt;% lag()) %&gt;% mutate(diff = sales_today - sales_yest) %&gt;% head() ## # Source: SQL [6 x 4] ## # Database: postgres [guest@localhost:5432/knock100] ## sales_ymd sales_today sales_yest diff ## &lt;int&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; ## 1 20190504 49561 NA NA ## 2 20180414 27599 49561 -21962 ## 3 20170416 16442 27599 -11157 ## 4 20190422 37044 16442 20602 ## 5 20190710 27796 37044 - 9248 ## 6 20181027 28497 27796 701 R-042 レシート明細データ（df_receipt）の売上金額（amount）を日付（sales_ymd）ごとに集計し、各日付のデータに対し、前回、前々回、3回前に売上があった日のデータを結合せよ。そして結果を10件表示せよ。 receipt_tbl %&gt;% group_by(sales_ymd) %&gt;% summarise(sales_daily = sum(sales_ymd)) %&gt;% mutate( across( .cols = sales_daily, .fns = list( lag_1 = ~ lag(.x, n = 1), lag_2 = ~ lag(.x, n = 2), lag_3 = ~ lag(.x, n = 3) ) ) ) %&gt;% head() ## # Source: SQL [6 x 5] ## # Database: postgres [guest@localhost:5432/knock100] ## sales_ymd sales_daily sales_daily_lag_1 sales_daily_lag_2 sales_daily_lag_3 ## &lt;int&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; ## 1 20190504 2382479472 NA NA NA ## 2 20180414 2118943470 2382479472 NA NA ## 3 20170416 1593462864 2118943470 2382479472 NA ## 4 20190422 2261327264 1593462864 2118943470 2382479472 ## 5 20190710 2059452420 2261327264 1593462864 2118943470 ## 6 20181027 1836473457 2059452420 2261327264 1593462864 collect() していいなら次のように書ける. .fns に与える formula のリスト (関数のリストでも可) を fms として事前に作っておく. 文字列を変換して formula を作ってしているのは, 変数 d の遅延評価を避けるため. library(stringr) D &lt;- 3 # lag formulas to apply fms &lt;- list() for (d in 1:D) fms[[d]] &lt;- stringr::str_c(&quot;~ lag(.x, n = &quot;, d, &quot;)&quot;) %&gt;% as.formula() receipt_tbl %&gt;% group_by(sales_ymd) %&gt;% summarise(sales_daily = sum(sales_ymd)) %&gt;% collect() %&gt;% mutate( across( .cols = sales_daily, .fns = fms, .names = &quot;{.col}_lag_{.fn}&quot; ) ) %&gt;% head() ## # A tibble: 6 × 5 ## sales_ymd sales_daily sales_daily_lag_1 sales_daily_lag_2 sales_daily_lag_3 ## &lt;int&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; ## 1 20190504 2382479472 NA NA NA ## 2 20180414 2118943470 2382479472 NA NA ## 3 20170416 1593462864 2118943470 2382479472 NA ## 4 20190422 2261327264 1593462864 2118943470 2382479472 ## 5 20190710 2059452420 2261327264 1593462864 2118943470 ## 6 20181027 1836473457 2059452420 2261327264 1593462864 R-043 レシート明細データ（df_receipt）と顧客データ（df_customer）を結合し、性別コード（gender_cd）と年代（ageから計算）ごとに売上金額（amount）を合計した売上サマリデータを作成せよ。性別コードは0が男性、1が女性、9が不明を表すものとする。 ただし、項目構成は年代、女性の売上金額、男性の売上金額、性別不明の売上金額の4項目とすること（縦に年代、横に性別のクロス集計）。また、年代は10歳ごとの階級とすること。 receipt_tbl %&gt;% inner_join(customer_tbl, by = &quot;customer_id&quot;) %&gt;% mutate(generation = age - age %% 10) %&gt;% group_by(generation, gender_cd) %&gt;% summarise(sales_amount = amount %&gt;% sum(), .groups = &quot;drop&quot;) %&gt;% tidyr::pivot_wider( names_from = gender_cd, names_prefix = &quot;sales&quot;, values_from = sales_amount, values_fill = 0 ) %&gt;% rename( sales_male = sales0, sales_female = sales1, sales_other = sales9 ) -&gt; sales_summary sales_summary ## # Source: SQL [9 x 4] ## # Database: postgres [guest@localhost:5432/knock100] ## generation sales_male sales_female sales_other ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 10 1591 149836 4317 ## 2 20 72940 1363724 44328 ## 3 30 177322 693047 50441 ## 4 40 19355 9320791 483512 ## 5 50 54320 6685192 342923 ## 6 60 272469 987741 71418 ## 7 70 13435 29764 2427 ## 8 80 46360 262923 5111 ## 9 90 0 6260 0 R-044 043で作成した売上サマリデータ（df_sales_summary）は性別の売上を横持ちさせたものであった。このデータから性別を縦持ちさせ、年代、性別コード、売上金額の3項目に変換せよ。ただし、性別コードは男性を“00”、女性を“01”、不明を“99”とする sales_summary %&gt;% rename(&quot;00&quot; = sales_male, &quot;01&quot; = sales_female, &quot;99&quot; = sales_other) %&gt;% tidyr::pivot_longer( cols = -generation, names_to = &quot;gender_cd&quot;, values_to = &quot;sales_amount&quot; ) %&gt;% head() ## # Source: SQL [6 x 3] ## # Database: postgres [guest@localhost:5432/knock100] ## generation gender_cd sales_amount ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 10 00 1591 ## 2 20 00 72940 ## 3 30 00 177322 ## 4 40 00 19355 ## 5 50 00 54320 ## 6 60 00 272469 R-045 顧客データ（df_customer）の生年月日（birth_day）は日付型でデータを保有している。これをYYYYMMDD形式の文字列に変換し、顧客ID（customer_id）とともに10件表示せよ。 library(stringr) # use stringr::str_replace_all() customer_tbl %&gt;% transmute( customer_id, date = birth_day %&gt;% as.character() %&gt;% str_replace_all(pattern = &quot;-&quot;, replacement = &quot;&quot;) ) %&gt;% head() ## # Source: SQL [6 x 2] ## # Database: postgres [guest@localhost:5432/knock100] ## customer_id date ## &lt;chr&gt; &lt;chr&gt; ## 1 CS021313000114 19810429 ## 2 CS037613000071 19520401 ## 3 CS031415000172 19761004 ## 4 CS028811000001 19330327 ## 5 CS001215000145 19950329 ## 6 CS020401000016 19740915 R-046 顧客データ（df_customer）の申し込み日（application_date）はYYYYMMDD形式の文字列型でデータを保有している。これを日付型に変換し、顧客ID（customer_id）とともに10件表示せよ。 customer_tbl %&gt;% transmute(customer_id, application_date = as.Date(application_date)) %&gt;% head() ## # Source: SQL [6 x 2] ## # Database: postgres [guest@localhost:5432/knock100] ## customer_id application_date ## &lt;chr&gt; &lt;date&gt; ## 1 CS021313000114 2015-09-05 ## 2 CS037613000071 2015-04-14 ## 3 CS031415000172 2015-05-29 ## 4 CS028811000001 2016-01-15 ## 5 CS001215000145 2017-06-05 ## 6 CS020401000016 2015-02-25 R-047 レシート明細データ（df_receipt）の売上日（sales_ymd）はYYYYMMDD形式の数値型でデータを保有している。これを日付型に変換し、レシート番号(receipt_no)、レシートサブ番号（receipt_sub_no）とともに10件表示せよ。 receipt_tbl %&gt;% transmute( sales_date = sales_ymd %&gt;% as.character() %&gt;% as.Date(), receipt_no, receipt_sub_no ) %&gt;% head() ## # Source: SQL [6 x 3] ## # Database: postgres [guest@localhost:5432/knock100] ## sales_date receipt_no receipt_sub_no ## &lt;date&gt; &lt;int&gt; &lt;int&gt; ## 1 2018-11-03 112 1 ## 2 2018-11-18 1132 2 ## 3 2017-07-12 1102 1 ## 4 2019-02-05 1132 1 ## 5 2018-08-21 1102 2 ## 6 2019-06-05 1112 1 日付処理へのコメント 日付処理は SQL で書いた方が遥かに楽なので, R にこだわる必要なし. R で日付を扱うパッケージとしては lubridate などがあるが, dbplyr 越しには使えないのでここでは書かない. というわけで R-048 から R-051 はスキップ. R-052 レシート明細データ（df_receipt）の売上金額（amount）を顧客ID（customer_id）ごとに合計の上、売上金額合計に対して2,000円以下を0、2,000円より大きい金額を1に二値化し、顧客ID、売上金額合計とともに10件表示せよ。ただし、顧客IDが“Z”から始まるのものは非会員を表すため、除外して計算すること。 library(stringr) # use stringr::str_detect() receipt_tbl %&gt;% filter(!str_detect(customer_id, &quot;^Z&quot;)) %&gt;% group_by(customer_id) %&gt;% summarise(amount = sum(amount, na.rm = TRUE)) %&gt;% mutate(amount_over_2000 = if_else(amount &gt; 2000, 1, 0)) %&gt;% head() ## # Source: SQL [6 x 3] ## # Database: postgres [guest@localhost:5432/knock100] ## customer_id amount amount_over_2000 ## &lt;chr&gt; &lt;int64&gt; &lt;dbl&gt; ## 1 CS001311000059 2302 1 ## 2 CS004614000122 248 0 ## 3 CS003512000043 298 0 ## 4 CS011615000061 246 0 ## 5 CS029212000033 3604 1 ## 6 CS007515000119 7157 1 R-053 顧客データ（df_customer）の郵便番号（postal_cd）に対し、東京（先頭3桁が100〜209のもの）を1、それ以外のものを0に二値化せよ。さらにレシート明細データ（df_receipt）と結合し、全期間において売上実績のある顧客数を、作成した二値ごとにカウントせよ。 customer_tbl %&gt;% mutate( is_tokyo = dplyr::between(substr(postal_cd, 1, 3) %&gt;% as.integer(), 100, 209) %&gt;% if_else(1, 0) ) %&gt;% inner_join(receipt_tbl, by = &quot;customer_id&quot;) %&gt;% group_by(is_tokyo) %&gt;% summarise(amount = n_distinct(customer_id)) %&gt;% head() ## # Source: SQL [2 x 2] ## # Database: postgres [guest@localhost:5432/knock100] ## is_tokyo amount ## &lt;dbl&gt; &lt;int64&gt; ## 1 0 3906 ## 2 1 4400 R-054 顧客データ（df_customer）の住所（address）は、埼玉県、千葉県、東京都、神奈川県のいずれかとなっている。都道府県毎にコード値を作成し、顧客ID、住所とともに10件表示せよ。値は埼玉県を11、千葉県を12、東京都を13、神奈川県を14とすること。 pref_vec &lt;- c(&quot;埼玉県&quot;, &quot;千葉県&quot;, &quot;東京都&quot;, &quot;神奈川&quot;) pref_map &lt;- function(str) which(str == pref_vec) + 10 %&gt;% as.integer() customer_tbl %&gt;% select(customer_id, address) %&gt;% collect() %&gt;% mutate( across( .cols = address, .fns = function(cls) purrr::map_int(cls, ~ substr(.x, 1, 3) %&gt;% pref_map()), .names = &quot;pref_code&quot; ) ) %&gt;% head() ## # A tibble: 6 × 3 ## customer_id address pref_code ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 CS021313000114 神奈川県伊勢原市粟窪********** 14 ## 2 CS037613000071 東京都江東区南砂********** 13 ## 3 CS031415000172 東京都渋谷区代々木********** 13 ## 4 CS028811000001 神奈川県横浜市泉区和泉町********** 14 ## 5 CS001215000145 東京都大田区仲六郷********** 13 ## 6 CS020401000016 東京都板橋区若木********** 13 R-055 レシート明細（df_receipt）データの売上金額（amount）を顧客ID（customer_id）ごとに合計し、その合計金額の四分位点を求めよ。その上で、顧客ごとの売上金額合計に対して以下の基準でカテゴリ値を作成し、顧客ID、売上金額合計とともに10件表示せよ。カテゴリ値は順に1〜4とする。 最小値以上第1四分位未満: 1を付与 第1四分位以上第2四分位未満: 2を付与 第2四分位以上第3四分位未満: 3を付与 第3四分位以上: 4を付与 公式回答のように case_when で場合分けするのが素直なやり方だが, カテゴリ数が増えたとき非常に冗長なコードとなる. collect()を使ってもよいなら, 以下のような書き方もできる. receipt_tbl %&gt;% group_by(customer_id) %&gt;% summarise(amount = sum(amount)) %&gt;% collect() %&gt;% mutate( across( .cols = amount, .fns = function(cls) { q &lt;- quantile(cls, probs = c(0.25, 0.5, 0.75, 1.0)) purrr::map_int(cls, ~ which(.x &lt;= q) %&gt;% min()) }, .names = &quot;pct_group&quot; ) ) %&gt;% head() ## # A tibble: 6 × 3 ## customer_id amount pct_group ## &lt;chr&gt; &lt;int64&gt; &lt;int&gt; ## 1 CS001311000059 2302 3 ## 2 CS004614000122 248 1 ## 3 CS003512000043 298 1 ## 4 CS011615000061 246 1 ## 5 CS029212000033 3604 3 ## 6 CS007515000119 7157 4 R-056 顧客データ（df_customer）の年齢（age）をもとに10歳刻みで年代を算出し、顧客ID（customer_id）、生年月日（birth_day）とともに10件表示せよ。ただし、60歳以上は全て60歳代とすること。年代を表すカテゴリ名は任意とする。 customer_tbl %&gt;% mutate(generation = if_else(age &gt;= 60, 60, age - age %% 10)) -&gt; customer_generation customer_generation %&gt;% select(customer_id, birth_day, generation) %&gt;% head() ## # Source: SQL [6 x 3] ## # Database: postgres [guest@localhost:5432/knock100] ## customer_id birth_day generation ## &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; ## 1 CS021313000114 1981-04-29 30 ## 2 CS037613000071 1952-04-01 60 ## 3 CS031415000172 1976-10-04 40 ## 4 CS028811000001 1933-03-27 60 ## 5 CS001215000145 1995-03-29 20 ## 6 CS020401000016 1974-09-15 40 R-057 056の抽出結果と性別コード（gender_cd）により、新たに性別×年代の組み合わせを表すカテゴリデータを作成し、10件表示せよ。組み合わせを表すカテゴリの値は任意とする。 customer_generation %&gt;% mutate(gender_generation = gender_cd + generation) %&gt;% select( customer_id, gender_cd, gender, age, generation, gender_generation ) %&gt;% head() ## # Source: SQL [6 x 6] ## # Database: postgres [guest@localhost:5432/knock100] ## customer_id gender_cd gender age generation gender_generation ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 CS021313000114 1 女性 37 30 31 ## 2 CS037613000071 9 不明 66 60 69 ## 3 CS031415000172 1 女性 42 40 41 ## 4 CS028811000001 1 女性 86 60 61 ## 5 CS001215000145 1 女性 24 20 21 ## 6 CS020401000016 0 男性 44 40 40 R-058 顧客データ（df_customer）の性別コード（gender_cd）をダミー変数化し、顧客ID（customer_id）とともに10件表示せよ。 customer_tbl %&gt;% select(customer_id, gender_cd) %&gt;% mutate(value = 1) %&gt;% tidyr::pivot_wider( names_from = gender_cd, names_prefix = &quot;gender_cd&quot;, values_from = value, values_fill = 0 ) ## # Source: SQL [?? x 4] ## # Database: postgres [guest@localhost:5432/knock100] ## customer_id gender_cd0 gender_cd9 gender_cd1 ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 CS001105000001 1 0 0 ## 2 CS001112000009 0 0 1 ## 3 CS001112000019 0 0 1 ## 4 CS001112000021 0 0 1 ## 5 CS001112000023 0 0 1 ## 6 CS001112000024 0 0 1 ## 7 CS001112000029 0 0 1 ## 8 CS001112000030 0 0 1 ## 9 CS001113000004 0 0 1 ## 10 CS001113000010 0 0 1 ## # … with more rows R-059 レシート明細データ（df_receipt）の売上金額（amount）を顧客ID（customer_id）ごとに合計し、売上金額合計を平均0、標準偏差1に標準化して顧客ID、売上金額合計とともに10件表示せよ。標準化に使用する標準偏差は、分散の平方根、もしくは不偏分散の平方根のどちらでも良いものとする。ただし、顧客IDが“Z”から始まるのものは非会員を表すため、除外して計算すること。 scale 関数を dbplyr 越しに使えないので, mean と sd を使ってベタ書きする. library(stringr) # stringr::str_detect() receipt_tbl %&gt;% filter(!str_detect(customer_id, &quot;^Z&quot;)) %&gt;% group_by(customer_id) %&gt;% summarise(amount = sum(amount, na.rm = TRUE)) %&gt;% mutate(std_amount = (amount - mean(amount)) / sd(amount)) %&gt;% head() ## # Source: SQL [6 x 3] ## # Database: postgres [guest@localhost:5432/knock100] ## customer_id amount std_amount ## &lt;chr&gt; &lt;int64&gt; &lt;dbl&gt; ## 1 CS001311000059 2302 -0.0903 ## 2 CS004614000122 248 -0.845 ## 3 CS003512000043 298 -0.827 ## 4 CS011615000061 246 -0.846 ## 5 CS029212000033 3604 0.388 ## 6 CS007515000119 7157 1.69 collect() していいなら, scale 関数を使って公式回答のように書ける. library(stringr) # stringr::str_detect() receipt_tbl %&gt;% filter(!str_detect(customer_id, &quot;^Z&quot;)) %&gt;% group_by(customer_id) %&gt;% summarise(amount = sum(amount, na.rm = TRUE)) %&gt;% collect() %&gt;% mutate(std_amount = scale(amount, center = TRUE, scale = TRUE)) %&gt;% head() ## # A tibble: 6 × 3 ## customer_id amount std_amount[,1] ## &lt;chr&gt; &lt;int64&gt; &lt;dbl&gt; ## 1 CS001311000059 2302 -0.0903 ## 2 CS004614000122 248 -0.845 ## 3 CS003512000043 298 -0.827 ## 4 CS011615000061 246 -0.846 ## 5 CS029212000033 3604 0.388 ## 6 CS007515000119 7157 1.69 R-060 レシート明細データ（df_receipt）の売上金額（amount）を顧客ID（customer_id）ごとに合計し、売上金額合計を最小値0、最大値1に正規化して顧客ID、売上金額合計とともに10件表示せよ。ただし、顧客IDが“Z”から始まるのものは非会員を表すため、除外して計算すること。 library(stringr) # stringr::str_detect() receipt_tbl %&gt;% filter(!str_detect(customer_id, &quot;^Z&quot;)) %&gt;% group_by(customer_id) %&gt;% summarise(amount = sum(amount, na.rm = TRUE)) %&gt;% mutate(relative_pos = as.numeric((amount - min(amount))) / (max(amount) - min(amount))) %&gt;% head(10) ## # Source: SQL [10 x 3] ## # Database: postgres [guest@localhost:5432/knock100] ## customer_id amount relative_pos ## &lt;chr&gt; &lt;int64&gt; &lt;dbl&gt; ## 1 CS001311000059 2302 0.0970 ## 2 CS004614000122 248 0.00773 ## 3 CS003512000043 298 0.00991 ## 4 CS011615000061 246 0.00765 ## 5 CS029212000033 3604 0.154 ## 6 CS007515000119 7157 0.308 ## 7 CS034515000123 3699 0.158 ## 8 CS004315000058 490 0.0182 ## 9 CS026414000014 6671 0.287 ## 10 CS001615000099 768 0.0303 R-069 レシート明細データ（df_receipt）と商品データ（df_product）を結合し、顧客毎に全商品の売上金額合計と、カテゴリ大区分コード（category_major_cd）が“07”（瓶詰缶詰）の売上金額合計を計算の上、両者の比率を求めよ。抽出対象はカテゴリ大区分コード“07”（瓶詰缶詰）の売上実績がある顧客のみとし、結果を10件表示せよ。 receipt_tbl %&gt;% inner_join(product_tbl, by = &quot;product_cd&quot;) %&gt;% group_by(customer_id) %&gt;% summarise( amount_canned = sum(if_else(category_major_cd == &quot;07&quot;, amount, 0), na.rm = TRUE), amount_total = sum(amount) ) %&gt;% filter(amount_canned &gt; 0) %&gt;% mutate(canned_ratio = as.numeric(amount_canned) / amount_total) %&gt;% head(10) ## # Source: SQL [10 x 4] ## # Database: postgres [guest@localhost:5432/knock100] ## customer_id amount_canned amount_total canned_ratio ## &lt;chr&gt; &lt;dbl&gt; &lt;int64&gt; &lt;dbl&gt; ## 1 CS001113000004 1298 1298 1 ## 2 CS001114000005 486 626 0.776 ## 3 CS001115000010 2694 3044 0.885 ## 4 CS001205000004 346 1988 0.174 ## 5 CS001205000006 2004 3337 0.601 ## 6 CS001212000027 200 448 0.446 ## 7 CS001212000031 296 296 1 ## 8 CS001212000046 108 228 0.474 ## 9 CS001212000070 308 456 0.675 ## 10 CS001213000018 145 243 0.597 R-070 レシート明細データ（df_receipt）の売上日（sales_ymd）に対し、顧客データ（df_customer）の会員申込日（application_date）からの経過日数を計算し、顧客ID（customer_id）、売上日、会員申込日とともに10件表示せよ（sales_ymdは数値、application_dateは文字列でデータを保持している点に注意）。 collect() しないなら日付周りは SQL でやった方がマシだと思うので, ここでは collect() する前提で lubridate パッケージを使う. lubridate::ymd() で文字列や数値を日付型に変換し, 差分時間を lubridate::interval に流して, %/% days(1) などで希望単位での (端数切捨ての) 経過時間を得る. %/% days(1) の部分を %/% months(1) や %/% years(1) や %/% seconds(1) とするだけで類似問題を処理できる. customer_tbl %&gt;% inner_join(receipt_tbl %&gt;% select(customer_id, sales_ymd), by = &quot;customer_id&quot;) %&gt;% select(customer_id, sales_ymd, application_date) %&gt;% collect() %&gt;% mutate(elapsed_days = lubridate::interval(lubridate::ymd(application_date), lubridate::ymd(sales_ymd)) %/% lubridate::days(1)) %&gt;% head() ## # A tibble: 6 × 4 ## customer_id sales_ymd application_date elapsed_days ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 CS006214000001 20181103 20150201 1371 ## 2 CS008415000097 20181118 20150322 1337 ## 3 CS028414000014 20170712 20150711 732 ## 4 CS025415000050 20180821 20160131 933 ## 5 CS003515000195 20190605 20150306 1552 ## 6 CS024514000042 20181205 20151010 1152 R-074 レシート明細データ（df_receipt）の売上日（sales_ymd）に対し、当該週の月曜日からの経過日数を計算し、売上日、直前の月曜日付とともに10件表示せよ（sales_ymdは数値でデータを保持している点に注意）。 receipt_tbl %&gt;% select(sales_ymd) %&gt;% collect() %&gt;% mutate( elapsed_weekdays = lubridate::ymd(sales_ymd) %&gt;% lubridate::wday(week_start = 1) - 1, last_monday = lubridate::ymd(sales_ymd) - elapsed_weekdays ) %&gt;% head() ## # A tibble: 6 × 3 ## sales_ymd elapsed_weekdays last_monday ## &lt;int&gt; &lt;dbl&gt; &lt;date&gt; ## 1 20181103 5 2018-10-29 ## 2 20181118 6 2018-11-12 ## 3 20170712 2 2017-07-10 ## 4 20190205 1 2019-02-04 ## 5 20180821 1 2018-08-20 ## 6 20190605 2 2019-06-03 R-078 レシート明細データ（df_receipt）の売上金額（amount）を顧客単位に合計し、合計した売上金額の外れ値を抽出せよ。ただし、顧客IDが“Z”から始まるのものは非会員を表すため、除外して計算すること。なお、ここでは外れ値を第1四分位と第3四分位の差であるIQRを用いて、「第1四分位数-1.5×IQR」を下回るもの、または「第3四分位数+1.5×IQR」を超えるものとする。結果は10件表示せよ。 dbplyr と中央値計算の相性の悪さから, collect() するしかない. collect() しないなら SQL でサブクエリ書くのが現実的. receipt_tbl %&gt;% filter(!str_detect(customer_id, &quot;^Z&quot;)) %&gt;% group_by(customer_id) %&gt;% summarise(amount = sum(amount, na.rm = TRUE)) %&gt;% collect() %&gt;% filter( amount %&gt;% { . &gt; quantile(., probs = 0.25) + 1.5 * IQR(.) | . &lt; quantile(., probs = 0.25) - 1.5 * IQR(.) } ) %&gt;% head() ## # A tibble: 6 × 2 ## customer_id amount ## &lt;chr&gt; &lt;int64&gt; ## 1 CS007515000119 7157 ## 2 CS026414000014 6671 ## 3 CS016414000063 6207 ## 4 CS039814000011 8031 ## 5 CS013415000226 8362 ## 6 CS009415000117 8229 R-079 商品データ（df_product）の各項目に対し、欠損数を確認せよ。 product_tbl %&gt;% summarise(across(.cols = everything(), .fns = ~ if_else(is.na(.x), 1, 0) %&gt;% sum(), .names = &quot;{.col}_NA&quot;)) ## # Source: SQL [1 x 6] ## # Database: postgres [guest@localhost:5432/knock100] ## product_cd_NA category_major_… category_medium… category_small_… unit_price_NA ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0 0 0 0 7 ## # … with 1 more variable: unit_cost_NA &lt;dbl&gt; R-080 商品データ（df_product）のいずれかの項目に欠損が発生しているレコードを全て削除した新たな商品データを作成せよ。なお、削除前後の件数を表示させ、079で確認した件数だけ減少していることも確認すること。 product_tbl %&gt;% filter(if_all(everything(), ~ !is.na(.))) %&gt;% head() ## # Source: SQL [6 x 6] ## # Database: postgres [guest@localhost:5432/knock100] ## product_cd category_major_cd category_medium_cd category_small_cd unit_price ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 P040101001 04 0401 040101 198 ## 2 P040101002 04 0401 040101 218 ## 3 P040101003 04 0401 040101 230 ## 4 P040101004 04 0401 040101 248 ## 5 P040101005 04 0401 040101 268 ## 6 P040101006 04 0401 040101 298 ## # … with 1 more variable: unit_cost &lt;int&gt; データを手元にダウンロードしていいなら complete.casesも手軽. product_tbl %&gt;% collect() %&gt;% filter(complete.cases(.)) %&gt;% head() ## # A tibble: 6 × 6 ## product_cd category_major_cd category_medium_cd category_small_cd unit_price ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 P040101001 04 0401 040101 198 ## 2 P040101002 04 0401 040101 218 ## 3 P040101003 04 0401 040101 230 ## 4 P040101004 04 0401 040101 248 ## 5 P040101005 04 0401 040101 268 ## 6 P040101006 04 0401 040101 298 ## # … with 1 more variable: unit_cost &lt;int&gt; R-081 単価（unit_price）と原価（unit_cost）の欠損値について、それぞれの平均値で補完した新たな商品データを作成せよ。なお、平均値については1円未満を丸めること（四捨五入または偶数への丸めで良い）。補完実施後、各項目について欠損が生じていないことも確認すること。 product_tbl %&gt;% mutate(across(starts_with(&quot;unit_&quot;), ~ coalesce(.x, mean(.x) %&gt;% round()))) ## # Source: SQL [?? x 6] ## # Database: postgres [guest@localhost:5432/knock100] ## product_cd category_major_cd category_medium_cd category_small_cd unit_price ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 P040101001 04 0401 040101 198 ## 2 P040101002 04 0401 040101 218 ## 3 P040101003 04 0401 040101 230 ## 4 P040101004 04 0401 040101 248 ## 5 P040101005 04 0401 040101 268 ## 6 P040101006 04 0401 040101 298 ## 7 P040101007 04 0401 040101 338 ## 8 P040101008 04 0401 040101 420 ## 9 P040101009 04 0401 040101 498 ## 10 P040101010 04 0401 040101 580 ## # … with more rows, and 1 more variable: unit_cost &lt;dbl&gt; R-083 単価（unit_price）と原価（unit_cost）の欠損値について、各商品のカテゴリ小区分コード（category_small_cd）ごとに算出した中央値で補完した新たな商品データを作成せよ。なお、中央値については1円未満を丸めること（四捨五入または偶数への丸めで良い）。補完実施後、各項目について欠損が生じていないことも確認すること。 collect() していいならgroup_by(category_small_cd) と dplyr::group_modify で, テーブルをカテゴリ別に分割 (テーブルのリストを作成) 分割後の各テーブルごとに欠損処理を行う テーブルを1つの結合 という処理を行う. 最初の .x には dplyr::group_modify() が作った各小テーブルが格納される. product_tbl %&gt;% collect() %&gt;% group_by(category_small_cd) %&gt;% dplyr::group_modify(~ mutate( .x, across( .cols = starts_with(&quot;unit_&quot;), .fns = ~ coalesce(.x, median(.x, na.rm = TRUE) %&gt;% round()) ) )) %&gt;% head() ## # A tibble: 6 × 6 ## # Groups: category_small_cd [1] ## category_small_cd product_cd category_major_cd category_medium_cd unit_price ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 040101 P040101001 04 0401 198 ## 2 040101 P040101002 04 0401 218 ## 3 040101 P040101003 04 0401 230 ## 4 040101 P040101004 04 0401 248 ## 5 040101 P040101005 04 0401 268 ## 6 040101 P040101006 04 0401 298 ## # … with 1 more variable: unit_cost &lt;dbl&gt; 元々のデータが大きくて collect() できないないときは, 公式回答のようにすればよいだろうが, inner_join のコストと, 欠損を持つカラムがもっと多い場合を考えると代替案が欲しいところである. その点がボトルネックになりづらい処理を考えてみたので以下に書き留める. 大まかなアイディアとしては, 欠損処理対象は欠損のある行だけなのだから, collect() するデータは欠損行だけに絞る. 欠損行だけだと欠損代入値が不明なので, 事前に代入値を計算しておき欠損行に結合する(これがinner_joinまでの作業) 欠損代入の計算だけを手元で行い (group_modify), 計算結果のテーブルはサーバー側に返して, サーバー側で非欠損行からなるテーブルと結合する. # delete tmp table if there is the one if (DBI::dbExistsTable(con, &quot;tmp&quot;)) { DBI::dbRemoveTable(con, &quot;tmp&quot;) } rows_to_impute &lt;- c(&quot;unit_price&quot;, &quot;unit_cost&quot;) product_tbl %&gt;% group_by(category_small_cd) %&gt;% # calculate median for each category summarise( across( .cols = all_of(rows_to_impute), .fns = ~ median(.x) %&gt;% round(), .names = &quot;{.col}_med&quot; ) ) %&gt;% # combine median and rows with missing value inner_join(product_tbl %&gt;% filter(if_any(everything(), ~ is.na(.))), by = &quot;category_small_cd&quot;) %&gt;% collect() %&gt;% group_by(category_small_cd) %&gt;% group_modify( ~ mutate( .x, across( .cols = all_of(rows_to_impute), .fns = ~ coalesce(.x, cur_data() %&gt;% summarise(across(stringr::str_c(cur_column(), &quot;_med&quot;), first)) %&gt;% pull(1)) ) ) ) %&gt;% select(-ends_with(&quot;_med&quot;)) %&gt;% # create a temporary table in server RPostgres::dbWriteTable(conn = con, name = &quot;tmp&quot;, value = ., overwirte = TRUE, temporary = TRUE) tbl(con, &quot;tmp&quot;) %&gt;% # merge tables dplyr::union(product_tbl %&gt;% filter(if_all(everything(), ~ !is.na(.)))) %&gt;% # check that the merged table has no NA cells summarise(across(.cols = everything(), .fns = ~ if_else(is.na(.x), 1, 0) %&gt;% sum(), .names = &quot;{.col}_NA&quot;)) ## # Source: SQL [1 x 6] ## # Database: postgres [guest@localhost:5432/knock100] ## category_small_… product_cd_NA category_major_… category_medium… unit_price_NA ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0 0 0 0 0 ## # … with 1 more variable: unit_cost_NA &lt;dbl&gt; # clean temp table if (DBI::dbExistsTable(con, &quot;tmp&quot;)) { DBI::dbRemoveTable(con, &quot;tmp&quot;) } 具体的な作業として面倒なのは, group_modify の coalesce の 2 引数目. 例として, この .x が unit_price のときを考える. 2 引数目には, 同じカテゴリの unit_price_med が来て欲しい. そこで, cur_data() で現在処理中のテーブル (これは group_modify によってリストに分割されたカテゴリごとの小テーブルである)を, cur_column() で現在処理中のカラム名をそれぞれ取得して, summarise(across(\"unit_price_med\", first)) としてこの列の最初の行の値を取ってきている. 各小テーブル内では, xxxx_xxxx_med の値は定数なので, サンプルする行はどこでもよい. R-084 顧客データ（df_customer）の全顧客に対して全期間の売上金額に占める2019年売上金額の割合を計算し、新たなデータを作成せよ。ただし、売上実績がない場合は0として扱うこと。そして計算した割合が0超のものを抽出し、結果を10件表示せよ。また、作成したデータに欠損が存在しないことを確認せよ。 receipt_tbl %&gt;% mutate(year = sales_ymd %&gt;% as.character() %&gt;% substr(1, 4)) %&gt;% group_by(customer_id) %&gt;% summarise( amount_all = sum(amount, na.rm = TRUE), amount_2019 = sum(if_else(year == &quot;2019&quot;, coalesce(amount, 0), 0), na.rm = TRUE) ) %&gt;% right_join(customer_tbl %&gt;% select(customer_id), by = &quot;customer_id&quot;) %&gt;% mutate(across( .cols = starts_with(&quot;amount&quot;), .fns = ~ coalesce(.x, .0) )) %&gt;% # the first of asked data filter(amount_2019 &gt; 0) %&gt;% # the second one mutate(ratio_2019 = amount_2019 / amount_all) %&gt;% head() ## # Source: SQL [6 x 4] ## # Database: postgres [guest@localhost:5432/knock100] ## customer_id amount_all amount_2019 ratio_2019 ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 CS031415000172 5088 2971 0.584 ## 2 CS015414000103 3122 874 0.280 ## 3 CS011215000048 3444 248 0.0720 ## 4 CS029415000023 5167 3767 0.729 ## 5 CS035415000029 7504 5823 0.776 ## 6 CS023513000066 771 208 0.270 R-087 顧客データ（df_customer）では、異なる店舗での申込みなどにより同一顧客が複数登録されている。名前（customer_name）と郵便番号（postal_cd）が同じ顧客は同一顧客とみなして1顧客1レコードとなるように名寄せした名寄顧客データを作成し、顧客データの件数、名寄顧客データの件数、重複数を算出せよ。ただし、同一顧客に対しては売上金額合計が最も高いものを残し、売上金額合計が同一もしくは売上実績がない顧客については顧客ID（customer_id）の番号が小さいものを残すこととする。 dbplyr のバージョンが古いと distinct の .keep_all = TRUE でエラーが出るかも. バージョン 2.2.1 では大丈夫だった. customer_tbl_u &lt;- customer_tbl %&gt;% left_join(receipt_tbl %&gt;% select(customer_id, amount), by = &quot;customer_id&quot;) %&gt;% group_by(across(all_of(customer_tbl %&gt;% colnames()))) %&gt;% summarise(sales_amount = amount %&gt;% sum() %&gt;% coalesce(0), .groups = &quot;drop&quot;) %&gt;% group_by(customer_name, postal_cd) %&gt;% window_order(desc(sales_amount), customer_id) %&gt;% distinct(customer_name, postal_cd, .keep_all = TRUE) %&gt;% ungroup() customer_tbl_u %&gt;% summarise(n()) ## # Source: SQL [1 x 1] ## # Database: postgres [guest@localhost:5432/knock100] ## # Ordered by: desc(sales_amount), customer_id ## `n()` ## &lt;int64&gt; ## 1 21941 R-089 売上実績がある顧客を、予測モデル構築のため学習用データとテスト用データに分割したい。それぞれ8:2の割合でランダムにデータを分割せよ。 データをダウンロードせずに処理を片付けたいので, 公式回答のように rsample::initial_split を使わずに dplyr::slice_sample() でゴリ押しする. dbplyr の現バージョンだと, dplyr::slice_sample() の prop = 変数を受け入れてくれないので, サンプルサイズ n = を直接指定している. customer_with_sales_history &lt;- receipt_tbl %&gt;% group_by(customer_id) %&gt;% summarise(sales_amount = amount %&gt;% sum(na.rm = TRUE), .groups = &quot;drop&quot;) %&gt;% filter(sales_amount &gt; 0) count_rows &lt;- function(table) { table %&gt;% summarise(n()) %&gt;% pull(1) %&gt;% as.double() } N &lt;- customer_with_sales_history %&gt;% count_rows() data_test &lt;- customer_with_sales_history %&gt;% slice_sample(n = 0.2 * N, replace = FALSE) data_train &lt;- dplyr::setdiff(customer_with_sales_history, data_test) &quot;size of N:&quot; %&gt;% paste(N) ## [1] &quot;size of N: 8307&quot; &quot;ratio of training data:&quot; %&gt;% paste(count_rows(data_train) / N) ## [1] &quot;ratio of training data: 0.800048152160828&quot; &quot;ratio of test data:&quot; %&gt;% paste(count_rows(data_test) / N) ## [1] &quot;ratio of test data: 0.199951847839172&quot; R-091 顧客データ（df_customer）の各顧客に対し、売上実績がある顧客数と売上実績がない顧客数が1:1となるようにアンダーサンプリングで抽出せよ。 前問と同様に dplyr::slice_sample() でゴリ押しする. 最後に, サンプリング結果を公式回答のように1つのテーブルに結合した. customer_sales_amount &lt;- customer_tbl %&gt;% left_join(receipt_tbl %&gt;% select(customer_id, amount), by = &quot;customer_id&quot;) %&gt;% group_by(customer_id) %&gt;% summarise(amount = amount %&gt;% sum(na.rm = TRUE) %&gt;% coalesce(0), .groups = &quot;drop&quot;) %&gt;% mutate(purchase = if_else(amount &gt; 0, 1, 0)) customer_with_sales_history &lt;- customer_sales_amount %&gt;% filter(amount &gt; 0) # size of down sampling size &lt;- count_rows(customer_sales_amount) %&gt;% min(customer_with_sales_history %&gt;% count_rows()) # union each of sampled group down_samples_tbl &lt;- customer_sales_amount %&gt;% filter(amount == 0) %&gt;% slice_sample(n = size) %&gt;% dplyr::union(customer_with_sales_history %&gt;% slice_sample(n = size)) down_samples_tbl %&gt;% group_by(purchase) %&gt;% summarise(n = n()) ## # Source: SQL [2 x 2] ## # Database: postgres [guest@localhost:5432/knock100] ## purchase n ## &lt;dbl&gt; &lt;int64&gt; ## 1 1 8306 ## 2 0 8306 4 References: dbplyr, DBI, RPostgres 参考資料 Overview 巨大なデータがSQLサーバーにあるときに、Rでどう立ち向かうかマニュアル：dbplyrパッケージを中心として Introduction to dbplyr R: Working with Databases DBI Introduction to DBI RSQLite &amp; DBIの使い方 DBI specification DBI: R Database Interface .pdf RPostgres RPostgres - Reference "]]
